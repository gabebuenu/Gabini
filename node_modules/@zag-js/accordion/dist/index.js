"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// ../../utilities/dom/dist/index.mjs
var dataAttr = (guard) => {
  return guard ? "" : void 0;
};
var isDom = () => typeof window !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
var pt = (v) => isDom() && v.test(getPlatform());
var vn = (v) => isDom() && v.test(navigator.vendor);
var isSafari = () => isApple() && vn(/apple/i);
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
function isDocument(el) {
  return el.nodeType === Node.DOCUMENT_NODE;
}
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getDocument(el) {
  if (isWindow(el))
    return el.document;
  if (isDocument(el))
    return el;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
function defineDomHelpers(helpers) {
  const dom2 = {
    getRootNode: (ctx) => {
      var _a;
      return ((_a = ctx.getRootNode) == null ? void 0 : _a.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument(dom2.getRootNode(ctx)),
    getWin: (ctx) => dom2.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom2.getDoc(ctx).activeElement,
    getById: (ctx, id) => dom2.getRootNode(ctx).getElementById(id)
  };
  return {
    ...dom2,
    ...helpers
  };
}
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
var sameKeyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let { key } = event;
  key = sameKeyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) {
    key = rtlKeyMap[key];
  }
  return key;
}
function queryAll(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function itemById(v, id) {
  return v.find((node) => node.id === id);
}
function indexOfId(v, id) {
  const item = itemById(v, id);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1)
    return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}

// ../../utilities/core/dist/index.mjs
function toArray(v) {
  if (!v)
    return [];
  return Array.isArray(v) ? v : [v];
}
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var add = (v, ...items) => v.concat(items);
var remove = (v, item) => removeAt(v, v.indexOf(item));
var removeAt = (v, i) => {
  if (i > -1)
    v.splice(i, 1);
  return v;
};
var isArray = (v) => Array.isArray(v);
var isString = (v) => typeof v === "string";
function warn(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && process.env.NODE_ENV !== "production") {
    console.warn(m);
  }
}

// src/accordion.dom.ts
var dom = defineDomHelpers({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `accordion:${ctx.id}`;
  },
  getItemId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.item) == null ? void 0 : _b.call(_a, value)) ?? `accordion:${ctx.id}:item:${value}`;
  },
  getContentId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.content) == null ? void 0 : _b.call(_a, value)) ?? `accordion:${ctx.id}:content:${value}`;
  },
  getTriggerId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.trigger) == null ? void 0 : _b.call(_a, value)) ?? `accordion:${ctx.id}:trigger:${value}`;
  },
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getTriggers: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom.getRootEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom.getTriggers(ctx)),
  getLastTriggerEl: (ctx) => last(dom.getTriggers(ctx)),
  getNextTriggerEl: (ctx, id) => nextById(dom.getTriggers(ctx), dom.getTriggerId(ctx, id)),
  getPrevTriggerEl: (ctx, id) => prevById(dom.getTriggers(ctx), dom.getTriggerId(ctx, id))
});

// src/accordion.connect.ts
function connect(state, send, normalize) {
  const focusedValue = state.context.focusedValue;
  const value = state.context.value;
  const multiple = state.context.multiple;
  const api = {
    value,
    setValue(value2) {
      if (multiple && !Array.isArray(value2)) {
        value2 = [value2];
      }
      send({ type: "SET_VALUE", value: value2 });
    },
    rootProps: normalize.element({
      "data-part": "root",
      id: dom.getRootId(state.context)
    }),
    getItemState(props) {
      return {
        isOpen: isArray(value) ? value.includes(props.value) : props.value === value,
        isFocused: focusedValue === props.value,
        isDisabled: props.disabled ?? state.context.disabled
      };
    },
    getItemProps(props) {
      const { isOpen, isFocused } = api.getItemState(props);
      return normalize.element({
        "data-part": "item",
        id: dom.getItemId(state.context, props.value),
        "data-expanded": dataAttr(isOpen),
        "data-focus": dataAttr(isFocused)
      });
    },
    getContentProps(props) {
      const { isOpen, isFocused, isDisabled } = api.getItemState(props);
      return normalize.element({
        "data-part": "content",
        role: "region",
        id: dom.getContentId(state.context, props.value),
        "aria-labelledby": dom.getTriggerId(state.context, props.value),
        hidden: !isOpen,
        "data-disabled": dataAttr(isDisabled),
        "data-focus": dataAttr(isFocused),
        "data-expanded": dataAttr(isOpen)
      });
    },
    getTriggerProps(props) {
      const { value: value2 } = props;
      const { isDisabled, isOpen } = api.getItemState(props);
      return normalize.button({
        "data-part": "trigger",
        type: "button",
        id: dom.getTriggerId(state.context, value2),
        "aria-controls": dom.getContentId(state.context, value2),
        "aria-expanded": isOpen,
        disabled: isDisabled,
        "aria-disabled": isDisabled,
        "data-expanded": dataAttr(isOpen),
        "data-ownedby": dom.getRootId(state.context),
        onFocus() {
          if (isDisabled)
            return;
          send({ type: "FOCUS", value: value2 });
        },
        onBlur() {
          if (isDisabled)
            return;
          send("BLUR");
        },
        onClick(event) {
          if (isDisabled)
            return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "CLICK", value: value2 });
        },
        onKeyDown(event) {
          if (isDisabled)
            return;
          const keyMap = {
            ArrowDown() {
              send({ type: "ARROW_DOWN", value: value2 });
            },
            ArrowUp() {
              send({ type: "ARROW_UP", value: value2 });
            },
            Home() {
              send({ type: "HOME", value: value2 });
            },
            End() {
              send({ type: "END", value: value2 });
            }
          };
          const key = getEventKey(event, {
            dir: state.context.dir,
            orientation: "vertical"
          });
          const exec = keyMap[key];
          if (exec) {
            exec(event);
            event.preventDefault();
          }
        }
      });
    }
  };
  return api;
}

// src/accordion.machine.ts
var import_core = require("@zag-js/core");
var { and, not } = import_core.guards;
function machine(ctx) {
  return (0, import_core.createMachine)(
    {
      id: "accordion",
      initial: "unknown",
      context: {
        focusedValue: null,
        value: null,
        collapsible: false,
        multiple: false,
        ...ctx
      },
      watch: {
        value: ["checkValue", "invokeOnChange"]
      },
      created: ["checkValue"],
      on: {
        SET_VALUE: {
          actions: "setValue"
        }
      },
      states: {
        unknown: {
          on: {
            SETUP: "idle"
          }
        },
        idle: {
          on: {
            FOCUS: {
              target: "focused",
              actions: "setFocusedValue"
            }
          }
        },
        focused: {
          on: {
            ARROW_DOWN: {
              actions: "focusNext"
            },
            ARROW_UP: {
              actions: "focusPrev"
            },
            CLICK: [
              {
                guard: and("isExpanded", "canToggle"),
                actions: "collapse"
              },
              {
                guard: not("isExpanded"),
                actions: "expand"
              }
            ],
            HOME: {
              actions: "focusFirst"
            },
            END: {
              actions: "focusLast"
            },
            BLUR: {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        canToggle: (ctx2) => !!ctx2.collapsible || !!ctx2.multiple,
        isExpanded: (ctx2, evt) => {
          if (ctx2.multiple && Array.isArray(ctx2.value))
            return ctx2.value.includes(evt.value);
          return ctx2.value === evt.value;
        }
      },
      actions: {
        invokeOnChange(ctx2, evt) {
          var _a;
          if (evt.type !== "SETUP") {
            (_a = ctx2.onChange) == null ? void 0 : _a.call(ctx2, { value: ctx2.value });
          }
        },
        collapse(ctx2, evt) {
          ctx2.value = ctx2.multiple ? remove(toArray(ctx2.value), evt.value) : null;
        },
        expand(ctx2, evt) {
          ctx2.value = ctx2.multiple ? add(toArray(ctx2.value), evt.value) : evt.value;
        },
        focusFirst(ctx2) {
          var _a;
          (_a = dom.getFirstTriggerEl(ctx2)) == null ? void 0 : _a.focus();
        },
        focusLast(ctx2) {
          var _a;
          (_a = dom.getLastTriggerEl(ctx2)) == null ? void 0 : _a.focus();
        },
        focusNext(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const el = dom.getNextTriggerEl(ctx2, ctx2.focusedValue);
          el == null ? void 0 : el.focus();
        },
        focusPrev(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const el = dom.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          el == null ? void 0 : el.focus();
        },
        setFocusedValue(ctx2, evt) {
          ctx2.focusedValue = evt.value;
        },
        clearFocusedValue(ctx2) {
          ctx2.focusedValue = null;
        },
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        checkValue(ctx2) {
          if (ctx2.multiple && isString(ctx2.value)) {
            warn(
              `[accordion/invalid-value]
               Expected value for multiple accordion to be an 'array'
               but received 'string'. Value will be coarsed to 'array'`
            );
            ctx2.value = [ctx2.value];
          } else if (!ctx2.multiple && Array.isArray(ctx2.value)) {
            ctx2.value = ctx2.value[0];
          }
        }
      }
    }
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  connect,
  machine
});
