"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  connect: () => connect,
  machine: () => machine
});
module.exports = __toCommonJS(src_exports);

// ../../utilities/dom/dist/index.mjs
var dataAttr = (guard) => {
  return guard ? "" : void 0;
};
var ariaAttr = (guard) => {
  return guard ? "true" : void 0;
};
function isDocument(el) {
  return el.nodeType === Node.DOCUMENT_NODE;
}
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getDocument(el) {
  if (isWindow(el))
    return el.document;
  if (isDocument(el))
    return el;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
function defineDomHelpers(helpers) {
  const dom2 = {
    getRootNode: (ctx) => {
      var _a;
      return ((_a = ctx.getRootNode) == null ? void 0 : _a.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument(dom2.getRootNode(ctx)),
    getWin: (ctx) => dom2.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom2.getDoc(ctx).activeElement,
    getById: (ctx, id) => dom2.getRootNode(ctx).getElementById(id)
  };
  return {
    ...dom2,
    ...helpers
  };
}
function getNativeEvent(e) {
  return e.nativeEvent ?? e;
}
var isModifiedEvent = (v) => v.ctrlKey || v.altKey || v.metaKey;
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
var sameKeyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let { key } = event;
  key = sameKeyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) {
    key = rtlKeyMap[key];
  }
  return key;
}
function raf(fn) {
  const id = globalThis.requestAnimationFrame(fn);
  return function cleanup() {
    globalThis.cancelAnimationFrame(id);
  };
}
function queryAll(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};

// ../../utilities/core/dist/index.mjs
function invariant(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && process.env.NODE_ENV !== "production") {
    throw new Error(m);
  }
}

// src/pin-input.dom.ts
var dom = defineDomHelpers({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `pin-input:${ctx.id}`;
  },
  getInputId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.input) == null ? void 0 : _b.call(_a, id)) ?? `pin-input:${ctx.id}:${id}`;
  },
  getHiddenInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.hiddenInput) ?? `pin-input:${ctx.id}:hidden`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `pin-input:${ctx.id}:label`;
  },
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `input[data-ownedby=${ownerId}]`;
    return queryAll(dom.getRootEl(ctx), selector);
  },
  getFocusedEl: (ctx) => dom.getElements(ctx)[ctx.focusedIndex],
  getFirstInputEl: (ctx) => dom.getElements(ctx)[0],
  getHiddenInputEl: (ctx) => dom.getById(ctx, dom.getHiddenInputId(ctx))
});

// src/pin-input.connect.ts
function connect(state, send, normalize) {
  const isValueComplete = state.context.isValueComplete;
  const isInvalid = state.context.invalid;
  const focusedIndex = state.context.focusedIndex;
  const messages = state.context.messages;
  function focus() {
    var _a;
    (_a = dom.getFirstInputEl(state.context)) == null ? void 0 : _a.focus();
  }
  return {
    value: state.context.value,
    valueAsString: state.context.valueAsString,
    isValueComplete,
    setValue(value) {
      if (!Array.isArray(value)) {
        invariant("[pin-input/setValue] value must be an array");
      }
      send({ type: "SET_VALUE", value });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    setValueAtIndex(index, value) {
      send({ type: "SET_VALUE", value, index });
    },
    focus,
    rootProps: normalize.element({
      dir: state.context.dir,
      "data-part": "root",
      id: dom.getRootId(state.context),
      "data-invalid": dataAttr(isInvalid),
      "data-disabled": dataAttr(state.context.disabled),
      "data-complete": dataAttr(isValueComplete)
    }),
    labelProps: normalize.label({
      "data-part": "label",
      htmlFor: dom.getHiddenInputId(state.context),
      id: dom.getLabelId(state.context),
      "data-invalid": dataAttr(isInvalid),
      "data-disabled": dataAttr(state.context.disabled),
      "data-complete": dataAttr(isValueComplete),
      onClick: (event) => {
        event.preventDefault();
        focus();
      }
    }),
    hiddenInputProps: normalize.input({
      "aria-hidden": true,
      type: "text",
      tabIndex: -1,
      id: dom.getHiddenInputId(state.context),
      name: state.context.name,
      style: visuallyHiddenStyle,
      maxLength: state.context.valueLength,
      defaultValue: state.context.valueAsString
    }),
    getInputProps({ index }) {
      const inputType = state.context.type === "numeric" ? "tel" : "text";
      return normalize.input({
        "data-part": "input",
        disabled: state.context.disabled,
        "data-disabled": dataAttr(state.context.disabled),
        "data-complete": dataAttr(isValueComplete),
        id: dom.getInputId(state.context, index.toString()),
        "data-ownedby": dom.getRootId(state.context),
        "aria-label": messages.inputLabel(index, state.context.valueLength),
        inputMode: state.context.otp || state.context.type === "numeric" ? "numeric" : "text",
        "aria-invalid": ariaAttr(isInvalid),
        "data-invalid": dataAttr(isInvalid),
        type: state.context.mask ? "password" : inputType,
        value: state.context.value[index] || "",
        autoCapitalize: "none",
        autoComplete: state.context.otp ? "one-time-code" : "off",
        placeholder: focusedIndex === index ? "" : state.context.placeholder,
        onChange(event) {
          const evt = getNativeEvent(event);
          if (evt.isComposing)
            return;
          const { value } = event.currentTarget;
          if (evt.inputType === "insertFromPaste" || value.length > 2) {
            send({ type: "PASTE", value });
            event.preventDefault();
            return;
          }
          if (evt.inputType === "insertText") {
            send({ type: "INPUT", value });
          }
        },
        onKeyDown(event) {
          const evt = getNativeEvent(event);
          if (evt.isComposing || isModifiedEvent(evt))
            return;
          const keyMap = {
            Backspace() {
              send("BACKSPACE");
            },
            Delete() {
              send("DELETE");
            },
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            Enter() {
              send("ENTER");
            }
          };
          const key = getEventKey(event, { dir: state.context.dir });
          const exec = keyMap[key];
          if (exec) {
            exec(event);
            event.preventDefault();
          } else {
            if (key === "Tab")
              return;
            send({ type: "KEY_DOWN", value: key, preventDefault: () => event.preventDefault() });
          }
        },
        onFocus() {
          send({ type: "FOCUS", index });
        },
        onBlur() {
          send({ type: "BLUR", index });
        }
      });
    }
  };
}

// src/pin-input.machine.ts
var import_core = require("@zag-js/core");

// ../../utilities/form-utils/dist/index.mjs
function getWindow(el) {
  return (el == null ? void 0 : el.ownerDocument.defaultView) ?? window;
}
function getDescriptor(el, options) {
  const { type, property } = options;
  const proto = getWindow(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function dispatchInputValueEvent(el, value) {
  var _a;
  if (!el)
    return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement))
    return;
  const desc = getDescriptor(el, { type: "HTMLInputElement", property: "value" });
  (_a = desc.set) == null ? void 0 : _a.call(el, value);
  const event = new win.Event("input", { bubbles: true });
  el.dispatchEvent(event);
}

// src/pin-input.machine.ts
var { and, not } = import_core.guards;
function machine(ctx) {
  return (0, import_core.createMachine)(
    {
      id: "pin-input",
      initial: "unknown",
      context: {
        value: [],
        focusedIndex: -1,
        placeholder: "\u25CB",
        otp: false,
        type: "numeric",
        ...ctx,
        messages: {
          inputLabel: (index, length) => `pin code ${index + 1} of ${length}`,
          ...ctx.messages
        }
      },
      computed: {
        valueLength: (ctx2) => ctx2.value.length,
        filledValueLength: (ctx2) => ctx2.value.filter((v) => (v == null ? void 0 : v.trim()) !== "").length,
        isValueComplete: (ctx2) => ctx2.valueLength === ctx2.filledValueLength,
        valueAsString: (ctx2) => ctx2.value.join("")
      },
      watch: {
        focusedIndex: "focusInput",
        value: "invokeOnChange",
        isValueComplete: ["invokeOnComplete", "blurFocusedInputIfNeeded"]
      },
      on: {
        SET_VALUE: [
          {
            guard: "hasIndex",
            actions: "setValueAtIndex"
          },
          { actions: "setValue" }
        ],
        CLEAR_VALUE: [
          {
            guard: "isDisabled",
            actions: "clearValue"
          },
          {
            actions: ["clearValue", "setFocusIndexToFirst"]
          }
        ]
      },
      states: {
        unknown: {
          on: {
            SETUP: [
              {
                guard: "autoFocus",
                target: "focused",
                actions: ["setupValue", "setFocusIndexToFirst"]
              },
              {
                target: "idle",
                actions: "setupValue"
              }
            ]
          }
        },
        idle: {
          on: {
            FOCUS: {
              target: "focused",
              actions: "setFocusedIndex"
            }
          }
        },
        focused: {
          on: {
            INPUT: [
              {
                guard: and("isFinalValue", "isValidValue"),
                actions: "setFocusedValue"
              },
              {
                guard: "isValidValue",
                actions: ["setFocusedValue", "setNextFocusedIndex"]
              }
            ],
            PASTE: {
              guard: "isValidValue",
              actions: ["setPastedValue", "setLastValueFocusIndex"]
            },
            BLUR: {
              target: "idle",
              actions: "clearFocusedIndex"
            },
            DELETE: {
              guard: "hasValue",
              actions: "clearFocusedValue"
            },
            ARROW_LEFT: {
              actions: "setPrevFocusedIndex"
            },
            ARROW_RIGHT: {
              actions: "setNextFocusedIndex"
            },
            BACKSPACE: [
              {
                guard: "hasValue",
                actions: "clearFocusedValue"
              },
              {
                actions: ["setPrevFocusedIndex", "clearFocusedValue"]
              }
            ],
            ENTER: {
              guard: "isValueComplete",
              actions: "requestFormSubmit"
            },
            KEY_DOWN: {
              guard: not("isValidValue"),
              actions: ["preventDefault", "invokeOnInvalid"]
            }
          }
        }
      }
    },
    {
      guards: {
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        isValueEmpty: (_ctx, evt) => evt.value === "",
        hasValue: (ctx2) => ctx2.value[ctx2.focusedIndex] !== "",
        isValueComplete: (ctx2) => ctx2.isValueComplete,
        isValidValue: (ctx2, evt) => {
          if (!ctx2.pattern)
            return isValidType(evt.value, ctx2.type);
          const regex = new RegExp(ctx2.pattern, "g");
          return regex.test(evt.value);
        },
        isFinalValue: (ctx2) => {
          return ctx2.filledValueLength + 1 === ctx2.valueLength && ctx2.value.findIndex((v) => v.trim() === "") === ctx2.focusedIndex;
        },
        isLastInputFocused: (ctx2) => ctx2.focusedIndex === ctx2.valueLength - 1,
        hasIndex: (_ctx, evt) => evt.index !== void 0,
        isDisabled: (ctx2) => !!ctx2.disabled
      },
      actions: {
        setupValue: (ctx2) => {
          const inputs = dom.getElements(ctx2);
          const empty = Array.from({ length: inputs.length }).map(() => "");
          ctx2.value = Object.assign(empty, ctx2.value);
        },
        focusInput: (ctx2) => {
          raf(() => {
            var _a;
            if (ctx2.focusedIndex === -1)
              return;
            (_a = dom.getFocusedEl(ctx2)) == null ? void 0 : _a.focus();
          });
        },
        invokeOnComplete: (ctx2) => {
          var _a;
          if (!ctx2.isValueComplete)
            return;
          (_a = ctx2.onComplete) == null ? void 0 : _a.call(ctx2, { value: Array.from(ctx2.value), valueAsString: ctx2.valueAsString });
        },
        invokeOnChange: (ctx2, evt) => {
          var _a;
          if (evt.type === "SETUP")
            return;
          (_a = ctx2.onChange) == null ? void 0 : _a.call(ctx2, { value: Array.from(ctx2.value) });
          dispatchInputValueEvent(dom.getHiddenInputEl(ctx2), ctx2.valueAsString);
        },
        invokeOnInvalid: (ctx2, evt) => {
          var _a;
          (_a = ctx2.onInvalid) == null ? void 0 : _a.call(ctx2, { value: evt.value, index: ctx2.focusedIndex });
        },
        clearFocusedIndex: (ctx2) => {
          ctx2.focusedIndex = -1;
        },
        setValue: (ctx2, evt) => {
          assign(ctx2, evt.value);
        },
        setFocusedIndex: (ctx2, evt) => {
          ctx2.focusedIndex = evt.index;
        },
        setFocusedValue: (ctx2, evt) => {
          ctx2.value[ctx2.focusedIndex] = lastChar(evt.value);
        },
        setPastedValue(ctx2, evt) {
          raf(() => {
            const value = evt.value.substring(0, ctx2.valueLength);
            assign(ctx2, value.split("").filter(Boolean));
          });
        },
        setValueAtIndex: (ctx2, evt) => {
          ctx2.value[evt.index] = lastChar(evt.value);
        },
        clearValue: (ctx2) => {
          assign(ctx2, "");
        },
        clearFocusedValue: (ctx2) => {
          ctx2.value[ctx2.focusedIndex] = "";
        },
        setFocusIndexToFirst: (ctx2) => {
          ctx2.focusedIndex = 0;
        },
        setNextFocusedIndex: (ctx2) => {
          ctx2.focusedIndex = Math.min(ctx2.focusedIndex + 1, ctx2.valueLength - 1);
        },
        setPrevFocusedIndex: (ctx2) => {
          ctx2.focusedIndex = Math.max(ctx2.focusedIndex - 1, 0);
        },
        setLastValueFocusIndex: (ctx2) => {
          raf(() => {
            ctx2.focusedIndex = Math.min(ctx2.filledValueLength, ctx2.valueLength - 1);
          });
        },
        preventDefault(_, evt) {
          evt.preventDefault();
        },
        blurFocusedInputIfNeeded(ctx2) {
          if (!ctx2.blurOnComplete)
            return;
          raf(() => {
            var _a;
            (_a = dom.getFocusedEl(ctx2)) == null ? void 0 : _a.blur();
          });
        },
        requestFormSubmit(ctx2) {
          var _a;
          if (!ctx2.name)
            return;
          const input = dom.getHiddenInputEl(ctx2);
          (_a = input == null ? void 0 : input.form) == null ? void 0 : _a.requestSubmit();
        }
      }
    }
  );
}
var REGEX = {
  numeric: /^[0-9]+$/,
  alphabetic: /^[A-Za-z]+$/,
  alphanumeric: /^[a-zA-Z0-9]+$/i
};
function isValidType(value, type) {
  var _a;
  if (!type)
    return true;
  return !!((_a = REGEX[type]) == null ? void 0 : _a.test(value));
}
function assign(ctx, value) {
  const len = ctx.value.length;
  for (let i = 0; i < len; i++) {
    if (Array.isArray(value)) {
      if (!value[i])
        continue;
      ctx.value[i] = value[i];
    } else {
      ctx.value[i] = value;
    }
  }
}
function lastChar(value) {
  return value.charAt(value.length - 1);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  connect,
  machine
});
