import { RequiredBy, DirectionProperty, CommonProperties, Context, PropTypes, NormalizeProps } from '@zag-js/types';
import * as _zag_js_core from '@zag-js/core';
import { StateMachine } from '@zag-js/core';

declare type IntlMessages = {
    inputLabel: (index: number, length: number) => string;
};
declare type ElementIds = Partial<{
    root: string;
    hiddenInput: string;
    label: string;
    input(id: string): string;
}>;
declare type PublicContext = DirectionProperty & CommonProperties & {
    /**
     * The name of the input element. Useful for form submission.
     */
    name?: string;
    /**
     * The regular expression that the user-entered input value is checked against.
     */
    pattern?: string;
    /**
     * The ids of the elements in the pin input. Useful for composition.
     */
    ids?: ElementIds;
    /**
     * Whether the inputs are disabled
     */
    disabled?: boolean;
    /**
     * The placeholder text for the input
     */
    placeholder?: string;
    /**
     * Whether to auto-focus the first input.
     */
    autoFocus?: boolean;
    /**
     * Whether the pin input is in the invalid state
     */
    invalid?: boolean;
    /**
     * If `true`, the pin input component signals to its fields that they should
     * use `autocomplete="one-time-code"`.
     */
    otp?: boolean;
    /**
     * The value of the the pin input.
     */
    value: string[];
    /**
     * The type of value the pin-input should allow
     */
    type?: "alphanumeric" | "numeric" | "alphabetic";
    /**
     * Function called when all inputs have valid values
     */
    onComplete?: (details: {
        value: string[];
        valueAsString: string;
    }) => void;
    /**
     * Function called on input change
     */
    onChange?: (details: {
        value: string[];
    }) => void;
    /**
     * Function called when an invalid value is entered
     */
    onInvalid?: (details: {
        value: string;
        index: number;
    }) => void;
    /**
     * If `true`, the input's value will be masked just like `type=password`
     */
    mask?: boolean;
    /**
     * Whether to blur the input when the value is complete
     */
    blurOnComplete?: boolean;
    /**
     * Specifies the localized strings that identifies the accessibility elements and their states
     */
    messages: IntlMessages;
};
declare type UserDefinedContext = RequiredBy<PublicContext, "id">;
declare type ComputedContext = Readonly<{
    /**
     * @computed
     * The number of inputs
     */
    valueLength: number;
    /**
     * @computed
     * The number of inputs that are not empty
     */
    filledValueLength: number;
    /**
     * @computed
     * Whether all input values are valid
     */
    isValueComplete: boolean;
    /**
     * @computed
     * The string representation of the input values
     */
    valueAsString: string;
}>;
declare type PrivateContext = Context<{}>;
declare type MachineContext = PublicContext & PrivateContext & ComputedContext;
declare type MachineState = {
    value: "unknown" | "idle" | "focused";
};
declare type State = StateMachine.State<MachineContext, MachineState>;
declare type Send = StateMachine.Send<StateMachine.AnyEventObject>;

declare function connect<T extends PropTypes>(state: State, send: Send, normalize: NormalizeProps<T>): {
    value: string[];
    valueAsString: string;
    isValueComplete: boolean;
    setValue(value: string[]): void;
    clearValue(): void;
    setValueAtIndex(index: number, value: string): void;
    focus: () => void;
    rootProps: T["element"];
    labelProps: T["label"];
    hiddenInputProps: T["input"];
    getInputProps({ index }: {
        index: number;
    }): T["input"];
};

declare function machine(ctx: UserDefinedContext): _zag_js_core.Machine<MachineContext, MachineState, _zag_js_core.StateMachine.AnyEventObject>;

export { UserDefinedContext as Context, connect, machine };
