// ../../utilities/dom/dist/index.mjs
var dataAttr = (guard) => {
  return guard ? "" : void 0;
};
function isDocument(el) {
  return el.nodeType === Node.DOCUMENT_NODE;
}
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getDocument(el) {
  if (isWindow(el))
    return el.document;
  if (isDocument(el))
    return el;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
function defineDomHelpers(helpers) {
  const dom2 = {
    getRootNode: (ctx) => {
      var _a;
      return ((_a = ctx.getRootNode) == null ? void 0 : _a.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument(dom2.getRootNode(ctx)),
    getWin: (ctx) => dom2.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => dom2.getDoc(ctx).activeElement,
    getById: (ctx, id) => dom2.getRootNode(ctx).getElementById(id)
  };
  return {
    ...dom2,
    ...helpers
  };
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};

// src/checkbox.dom.ts
var dom = defineDomHelpers({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `checkbox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `checkbox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `checkbox:${ctx.id}:control`;
  },
  getInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.input) ?? `checkbox:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getInputEl: (ctx) => dom.getById(ctx, dom.getInputId(ctx))
});

// src/checkbox.connect.ts
function connect(state, send, normalize) {
  const isChecked = state.matches("checked");
  const isInteractive = state.context.isInteractive;
  const isIndeterminate = state.context.indeterminate;
  const isDisabled = state.context.disabled;
  const isInvalid = state.context.invalid;
  const isReadOnly = state.context.readonly;
  const isRequired = state.context.required;
  const isFocusable = state.context.focusable;
  const isActive = state.context.active;
  const isHovered = state.context.hovered;
  const isFocused = !isDisabled && state.context.focused;
  const ariaLabel = state.context["aria-label"];
  const ariaLabelledBy = state.context["aria-labelledby"] ?? dom.getLabelId(state.context);
  const ariaDescribedBy = state.context["aria-describedby"];
  const ariaChecked = isIndeterminate ? "mixed" : isChecked;
  const name = state.context.name;
  const value = state.context.value;
  const trulyDisabled = isDisabled && !isFocusable;
  const stateView = state.hasTag("checked") ? "checked" : "unchecked";
  const view = state.context.indeterminate ? "mixed" : stateView;
  return {
    isChecked,
    isDisabled,
    isIndeterminate,
    isFocused,
    isReadOnly,
    view,
    setChecked(checked) {
      send({ type: "SET_STATE", checked, manual: true });
    },
    setIndeterminate(indeterminate) {
      send({ type: "SET_INDETERMINATE", value: indeterminate });
    },
    rootProps: normalize.element({
      "data-part": "root",
      id: dom.getRootId(state.context),
      "data-focus": dataAttr(isFocused),
      "data-disabled": dataAttr(isDisabled),
      "data-checked": dataAttr(isChecked),
      "data-hover": dataAttr(isHovered),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly),
      onPointerMove() {
        if (!isInteractive)
          return;
        send({ type: "SET_HOVERED", value: true });
      },
      onPointerLeave() {
        if (!isInteractive)
          return;
        send({ type: "SET_HOVERED", value: false });
      },
      onPointerDown(event) {
        if (!isInteractive)
          return;
        if (isFocused)
          event.preventDefault();
        send({ type: "SET_ACTIVE", value: true });
      },
      onPointerUp() {
        if (!isInteractive)
          return;
        send({ type: "SET_ACTIVE", value: false });
      }
    }),
    labelProps: normalize.label({
      "data-part": "label",
      htmlFor: dom.getInputId(state.context),
      id: dom.getLabelId(state.context),
      "data-focus": dataAttr(isFocused),
      "data-hover": dataAttr(isHovered),
      "data-readonly": dataAttr(isReadOnly),
      "data-disabled": dataAttr(isDisabled),
      "data-checked": dataAttr(isChecked),
      "data-invalid": dataAttr(isInvalid),
      onPointerDown(event) {
        if (!isInteractive)
          return;
        event.preventDefault();
        event.stopPropagation();
      }
    }),
    controlProps: normalize.element({
      "data-part": "control",
      id: dom.getControlId(state.context),
      "data-focus": dataAttr(isFocused),
      "data-disabled": dataAttr(isDisabled),
      "data-hover": dataAttr(isHovered),
      "data-indeterminate": dataAttr(isIndeterminate),
      "data-invalid": dataAttr(isInvalid),
      "data-checked": dataAttr(isChecked),
      "data-readonly": dataAttr(isReadOnly),
      "aria-hidden": true,
      "data-active": dataAttr(isActive)
    }),
    inputProps: normalize.input({
      "data-part": "input",
      id: dom.getInputId(state.context),
      type: "checkbox",
      required: isRequired,
      defaultChecked: isChecked,
      disabled: trulyDisabled,
      "data-disabled": dataAttr(isDisabled),
      readOnly: isReadOnly,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      "aria-invalid": isInvalid,
      "aria-checked": ariaChecked,
      "aria-describedby": ariaDescribedBy,
      "aria-disabled": isDisabled,
      name,
      value,
      style: visuallyHiddenStyle,
      onChange() {
        send({ type: "TOGGLE" });
      },
      onBlur() {
        send({ type: "SET_FOCUSED", value: false });
      },
      onFocus() {
        send({ type: "SET_FOCUSED", value: true });
      },
      onKeyDown(event) {
        if (event.key === " ") {
          send({ type: "SET_ACTIVE", value: true });
        }
      },
      onKeyUp(event) {
        if (event.key === " ") {
          send({ type: "SET_ACTIVE", value: false });
        }
      }
    })
  };
}

// src/checkbox.machine.ts
import { createMachine, guards } from "@zag-js/core";

// ../../utilities/form-utils/dist/index.mjs
function getWindow(el) {
  return (el == null ? void 0 : el.ownerDocument.defaultView) ?? window;
}
function observeAttributes(node, attributes, fn) {
  if (!node)
    return;
  const attrs = Array.isArray(attributes) ? attributes : [attributes];
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attrs.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node, { attributes: true, attributeFilter: attrs });
  return () => obs.disconnect();
}
function getDescriptor(el, options) {
  const { type, property } = options;
  const proto = getWindow(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function dispatchInputCheckedEvent(el, checked) {
  var _a;
  if (!el)
    return;
  const win = getWindow(el);
  if (!(el instanceof win.HTMLInputElement))
    return;
  const desc = getDescriptor(el, { type: "HTMLInputElement", property: "checked" });
  (_a = desc.set) == null ? void 0 : _a.call(el, checked);
  const event = new win.Event("click", { bubbles: true });
  el.dispatchEvent(event);
}
function getClosestForm(el) {
  if (isFormElement(el))
    return el.form;
  else
    return el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el)
    return;
  const form = getClosestForm(el);
  form == null ? void 0 : form.addEventListener("reset", callback, { passive: true });
  return () => {
    form == null ? void 0 : form.removeEventListener("reset", callback);
  };
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el == null ? void 0 : el.closest("fieldset");
  if (!fieldset)
    return;
  callback(fieldset.disabled);
  return observeAttributes(fieldset, ["disabled"], () => callback(fieldset.disabled));
}

// src/checkbox.machine.ts
var { and } = guards;
function machine(ctx) {
  return createMachine(
    {
      id: "checkbox",
      initial: "unknown",
      context: {
        active: false,
        hovered: false,
        focused: false,
        disabled: false,
        readonly: false,
        ...ctx
      },
      watch: {
        indeterminate: "syncInputIndeterminate",
        disabled: "removeFocusIfNeeded"
      },
      computed: {
        isInteractive: (ctx2) => !(ctx2.readonly || ctx2.disabled)
      },
      activities: ["trackFormReset", "trackFieldsetDisabled"],
      on: {
        SET_STATE: [
          {
            guard: and("shouldCheck", "isInteractive"),
            target: "checked",
            actions: "dispatchChangeEvent"
          },
          {
            guard: "isInteractive",
            target: "unchecked",
            actions: "dispatchChangeEvent"
          }
        ],
        SET_ACTIVE: {
          actions: "setActive"
        },
        SET_HOVERED: {
          actions: "setHovered"
        },
        SET_FOCUSED: {
          actions: "setFocused"
        },
        SET_INDETERMINATE: {
          actions: "setIndeterminate"
        }
      },
      states: {
        unknown: {
          tags: ["unchecked"],
          on: {
            SETUP: ctx.defaultChecked ? "checked" : "unchecked"
          }
        },
        checked: {
          tags: ["checked"],
          on: {
            TOGGLE: {
              target: "unchecked",
              guard: "isInteractive",
              actions: ["invokeOnChange"]
            }
          }
        },
        unchecked: {
          tags: ["unchecked"],
          on: {
            TOGGLE: {
              target: "checked",
              guard: "isInteractive",
              actions: ["invokeOnChange"]
            }
          }
        }
      }
    },
    {
      guards: {
        shouldCheck: (_, evt) => evt.checked,
        isInteractive: (ctx2) => ctx2.isInteractive
      },
      activities: {
        trackFieldsetDisabled(ctx2) {
          return trackFieldsetDisabled(dom.getRootEl(ctx2), (disabled) => {
            if (disabled) {
              ctx2.disabled = disabled;
            }
          });
        },
        trackFormReset(ctx2, _evt, { send }) {
          return trackFormReset(dom.getInputEl(ctx2), () => {
            send({ type: "SET_STATE", checked: !!ctx2.defaultChecked });
          });
        }
      },
      actions: {
        invokeOnChange(ctx2, _evt, { state }) {
          var _a;
          const checked = state.matches("checked");
          (_a = ctx2.onChange) == null ? void 0 : _a.call(ctx2, { checked: ctx2.indeterminate ? "indeterminate" : checked });
        },
        setActive(ctx2, evt) {
          ctx2.active = evt.value;
        },
        setHovered(ctx2, evt) {
          ctx2.hovered = evt.value;
        },
        setFocused(ctx2, evt) {
          ctx2.focused = evt.value;
        },
        setIndeterminate(ctx2, evt) {
          ctx2.indeterminate = evt.value;
        },
        syncInputIndeterminate(ctx2) {
          const el = dom.getInputEl(ctx2);
          if (!el)
            return;
          el.indeterminate = Boolean(ctx2.indeterminate);
        },
        dispatchChangeEvent(ctx2, evt) {
          if (!evt.manual)
            return;
          const el = dom.getInputEl(ctx2);
          if (!el)
            return;
          dispatchInputCheckedEvent(el, evt.checked);
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
          }
        }
      }
    }
  );
}
export {
  connect,
  machine
};
