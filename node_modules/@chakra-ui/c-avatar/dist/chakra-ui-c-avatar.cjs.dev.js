'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var vueSystem = require('@chakra-ui/vue-system');
var vueLayout = require('@chakra-ui/vue-layout');
var vueUtils = require('@chakra-ui/vue-utils');
var utils = require('@chakra-ui/utils');

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _isSlot$1(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !vue.isVNode(s);
}

var _createContext = vueUtils.createContext({
  strict: false,
  name: "AvatarGroupContext"
}),
    AvatarGroupProvider = _createContext[0],
    useAvatarGroup = _createContext[1];
var CAvatarText = vue.defineComponent({
  props: _extends({
    text: {
      type: String,
      "default": ""
    }
  }, vueUtils.vueThemingProps),
  setup: function setup(props, ctx) {
    var themingProps = vue.computed(function () {
      return utils.filterUndefined({
        colorScheme: props.colorScheme,
        variant: props.variant,
        size: props.size,
        styleConfig: props.styleConfig
      });
    });
    var styles = vueSystem.useMultiStyleConfig("Avatar", themingProps);
    var containerStyles = vue.computed(function () {
      return _extends({}, styles.value.container, {
        display: styles.value.container.display || "flex",
        alignItems: "center",
        justifyContent: "center"
      });
    });
    var labelStyles = vue.computed(function () {
      return _extends({}, styles.value.label, {
        fontWeight: "medium"
      });
    });
    return function () {
      return vue.createVNode(vueSystem.chakra.div, vue.mergeProps({
        "__css": containerStyles.value
      }, ctx.attrs), {
        "default": function _default() {
          return [vue.createVNode(vueSystem.chakra.div, {
            "role": "img",
            "__css": labelStyles.value
          }, {
            "default": function _default() {
              return [props.text];
            }
          })];
        }
      });
    };
  }
});
var avatarGroupProps = _extends({
  max: {
    type: Number,
    "default": 2
  }
}, vueLayout.CWrapProps, vueUtils.vueThemingProps);
var CAvatarGroup = vue.defineComponent({
  props: avatarGroupProps,
  setup: function setup(props, _ref) {
    var slots = _ref.slots,
        attrs = _ref.attrs;
    var wrapProps = vue.computed(function () {
      return {
        spacing: props.spacing || "-0.75em",
        direction: props.direction || "row-reverse",
        justify: props.justify,
        align: props.align,
        shouldWrapChildren: props.shouldWrapChildren
      };
    });
    var themingProps = vue.computed(function () {
      return utils.filterUndefined({
        colorScheme: props.colorScheme,
        variant: props.variant,
        size: props.size,
        styleConfig: props.styleConfig
      });
    });
    var validChildren = vue.computed(function () {
      return vueUtils.getValidChildren(slots);
    });
    var visibleChildren = vue.computed(function () {
      return validChildren.value.slice(0, props.max);
    });
    var nbHidden = vue.computed(function () {
      return validChildren.value.length - props.max;
    });
    AvatarGroupProvider(themingProps);
    return function () {
      return vue.createVNode(vueLayout.CBox, vue.mergeProps({
        "__label": "avatar-group",
        "display": "flex"
      }, attrs), {
        "default": function _default() {
          return [vue.createVNode(vueLayout.CWrap, wrapProps.value, {
            "default": function _default() {
              return [nbHidden.value > 0 && vue.createVNode(vueLayout.CWrapItem, null, {
                "default": function _default() {
                  return [vue.createVNode(CAvatarText, vue.mergeProps(themingProps.value, {
                    "text": "+" + nbHidden.value
                  }), null)];
                }
              }), visibleChildren.value.map(function (child) {
                return vue.createVNode(vueLayout.CWrapItem, null, _isSlot$1(child) ? child : {
                  "default": function _default() {
                    return [child];
                  }
                });
              })];
            }
          })];
        }
      });
    };
  }
});

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _excluded = ["alt", "src", "srcset", "crossorigin", "decoding", "height", "ismap", "loading", "referrerpolicy", "sizes", "width", "usemap"];
var getInitials = function getInitials(name) {
  var _name$split = name.split(" "),
      firstName = _name$split[0],
      lastName = _name$split[1];

  if (firstName && lastName) {
    return "" + firstName.charAt(0) + lastName.charAt(0);
  } else {
    return name.charAt(0);
  }
};
var extractImgAttrs = function extractImgAttrs(attrs) {
  var alt = attrs.alt,
      src = attrs.src,
      srcset = attrs.srcset,
      crossorigin = attrs.crossorigin,
      decoding = attrs.decoding,
      height = attrs.height,
      ismap = attrs.ismap,
      loading = attrs.loading,
      referrerpolicy = attrs.referrerpolicy,
      sizes = attrs.sizes,
      width = attrs.width,
      usemap = attrs.usemap,
      rest = _objectWithoutPropertiesLoose(attrs, _excluded);

  var imgAttrs = utils.filterUndefined({
    alt: alt,
    src: src,
    srcset: srcset,
    crossorigin: crossorigin,
    decoding: decoding,
    height: height,
    ismap: ismap,
    loading: loading,
    referrerpolicy: referrerpolicy,
    sizes: sizes,
    width: width,
    usemap: usemap
  });
  return {
    imgAttrs: imgAttrs,
    rest: rest
  };
};

var useDynamicContainerStyles = function useDynamicContainerStyles(props, styles) {
  var theme = vueSystem.useTheme();
  var calculatedColorStyles = vue.computed(function () {
    var _theme$components, _theme$components$Ava, _theme$components$Ava2;

    return (_theme$components = theme.components) == null ? void 0 : (_theme$components$Ava = _theme$components.Avatar) == null ? void 0 : (_theme$components$Ava2 = _theme$components$Ava.baseStyle(props)) == null ? void 0 : _theme$components$Ava2.container;
  });
  return vue.computed(function () {
    return _extends({}, styles.value.container, {
      bg: calculatedColorStyles.value.bg,
      color: calculatedColorStyles.value.color,
      display: styles.value.container.display || "flex",
      alignItems: "center",
      justifyContent: "center"
    });
  });
};

var CAvatarDefaultImage = vue.defineComponent({
  setup: function setup(props) {
    var styles = vueSystem.useStyles();
    var containerStyles = useDynamicContainerStyles(props, styles);
    return function () {
      return vue.createVNode(vueLayout.CBox, {
        "__css": containerStyles.value
      }, {
        "default": function _default() {
          return [vue.createVNode("svg", {
            "fill": "#fff",
            "viewBox": "0 0 128 128",
            "role": "img"
          }, [vue.createVNode("g", null, [vue.createVNode("path", {
            "d": "M103,102.1388 C93.094,111.92 79.3504,118 64.1638,118 C48.8056,118 34.9294,111.768 25,101.7892 L25,95.2 C25,86.8096 31.981,80 40.6,80 L87.4,80 C96.019,80 103,86.8096 103,95.2 L103,102.1388 Z"
          }, null), vue.createVNode("path", {
            "d": "M63.9961647,24 C51.2938136,24 41,34.2938136 41,46.9961647 C41,59.7061864 51.2938136,70 63.9961647,70 C76.6985159,70 87,59.7061864 87,46.9961647 C87,34.2938136 76.6985159,24 63.9961647,24"
          }, null)])])];
        }
      });
    };
  }
});
var CAvatarInitials = vue.defineComponent({
  props: {
    name: {
      type: String,
      "default": ""
    },
    initials: {
      type: String,
      "default": ""
    }
  },
  setup: function setup(props) {
    var styles = vueSystem.useStyles();
    var containerStyles = useDynamicContainerStyles(props, styles);
    var labelStyles = vue.computed(function () {
      return _extends({}, styles.value.label, {
        fontWeight: "medium"
      });
    });
    return function () {
      return vue.createVNode(vueLayout.CBox, {
        "__css": containerStyles.value
      }, {
        "default": function _default() {
          return [vue.createVNode(vueSystem.chakra.div, {
            "role": "img",
            "aria-label": props.name,
            "__css": labelStyles.value
          }, {
            "default": function _default() {
              return [props.initials ? props.initials : props.name && getInitials(props.name)];
            }
          })];
        }
      });
    };
  }
});
var avatarProps = _extends({
  as: {
    type: [Object, String],
    "default": "span"
  },
  src: {
    type: String,
    "default": ""
  },
  name: {
    type: String,
    "default": ""
  },
  initials: {
    type: String,
    "default": ""
  }
}, vueUtils.vueThemingProps);
var CAvatar = vue.defineComponent({
  props: avatarProps,
  setup: function setup(props, _ref) {
    var _validChildren$value;

    var slots = _ref.slots,
        attrs = _ref.attrs;
    // Props handling
    var mergedProps = vue.computed(function () {
      return vue.mergeProps({}, props, attrs);
    });
    var ownProps = vue.computed(function () {
      return vueSystem.omitThemingProps(mergedProps.value);
    });
    var extractedAttrs = vue.computed(function () {
      return extractImgAttrs(ownProps.value);
    }); // State handling

    var error = vue.ref(false);
    var pending = vue.ref(true); // Fetching custom icon

    var validChildren = vue.ref(vueUtils.getValidChildren(slots));
    var customIcon = (_validChildren$value = validChildren.value) == null ? void 0 : _validChildren$value.find(function (child, index) {
      if (child.type.name === "CIcon") {
        validChildren.value.splice(index, 1);
        return true;
      }
    }); // Handling styles

    var avatarGroupStyles = useAvatarGroup();
    var themingProps = vue.computed(function () {
      var _avatarGroupStyles$va, _avatarGroupStyles$va2, _avatarGroupStyles$va3, _avatarGroupStyles$va4;

      return utils.filterUndefined({
        colorScheme: (avatarGroupStyles == null ? void 0 : (_avatarGroupStyles$va = avatarGroupStyles.value) == null ? void 0 : _avatarGroupStyles$va.colorScheme) || props.colorScheme,
        variant: (avatarGroupStyles == null ? void 0 : (_avatarGroupStyles$va2 = avatarGroupStyles.value) == null ? void 0 : _avatarGroupStyles$va2.variant) || props.variant,
        size: (avatarGroupStyles == null ? void 0 : (_avatarGroupStyles$va3 = avatarGroupStyles.value) == null ? void 0 : _avatarGroupStyles$va3.size) || props.size,
        styleConfig: (avatarGroupStyles == null ? void 0 : (_avatarGroupStyles$va4 = avatarGroupStyles.value) == null ? void 0 : _avatarGroupStyles$va4.styleConfig) || props.styleConfig
      });
    });
    var styles = vueSystem.useMultiStyleConfig("Avatar", themingProps);
    var containerStyles = useDynamicContainerStyles(props, styles);
    var imgStyles = vue.computed(function () {
      return _extends({
        objectFit: "cover"
      }, containerStyles.value);
    });
    vueSystem.StylesProvider(styles);
    return function () {
      return vue.createVNode(vueSystem.chakra.div, vue.mergeProps({
        "__label": "avatar",
        "__css": containerStyles.value
      }, extractedAttrs.value.rest), {
        "default": function _default() {
          return [!error.value && vue.createVNode(vueSystem.chakra.img, vue.mergeProps({
            "src": props.src,
            "__css": imgStyles.value,
            "onError": function onError() {
              error.value = true;
              pending.value = false;
            },
            "onLoad": function onLoad() {
              error.value = false;
              pending.value = false;
            },
            "alt": props.name,
            "aria-label": props.name,
            "display": pending.value ? "none" : containerStyles.value.display
          }, extractedAttrs.value.imgAttrs), null), (pending.value || error.value) && (props.name ? vue.createVNode(CAvatarInitials, vue.mergeProps({
            "initials": props.initials,
            "name": props.name
          }, extractedAttrs.value.rest), null) : customIcon != null ? customIcon : vue.createVNode(CAvatarDefaultImage, extractedAttrs.value.rest, null)), validChildren.value];
        }
      });
    };
  }
});

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !vue.isVNode(s);
}

var placementMap = {
  "top-start": {
    top: "0",
    insetStart: "0",
    transform: "translate(-25%, -25%)"
  },
  "top-end": {
    top: "0",
    insetEnd: "0",
    transform: "translate(25%, -25%)"
  },
  "bottom-start": {
    bottom: "0",
    insetStart: "0",
    transform: "translate(-25%, 25%)"
  },
  "bottom-end": {
    bottom: "0",
    insetEnd: "0",
    transform: "translate(25%, 25%)"
  }
};

var CAvatarBadgeProps = _extends({
  placement: String
}, vueUtils.vueThemingProps);

var CAvatarBadge = vue.defineComponent({
  props: _extends({}, CAvatarBadgeProps),
  setup: function setup(props, _ref) {
    var slots = _ref.slots,
        attrs = _ref.attrs;
    var styles = vueSystem.useStyles();
    var placementStyles = vue.computed(function () {
      return placementMap[props.placement || "bottom-end"] || "bottom-end";
    });
    var badgeStyles = vue.computed(function () {
      return _extends({}, styles.value.badge, placementStyles.value);
    });
    return function () {
      var _slot;

      return vue.createVNode(vueSystem.chakra.div, vue.mergeProps({
        "__label": "avatar-badge",
        "__css": badgeStyles.value
      }, props, attrs), _isSlot(_slot = vueUtils.getValidChildren(slots)) ? _slot : {
        "default": function _default() {
          return [_slot];
        }
      });
    };
  }
});

exports.CAvatar = CAvatar;
exports.CAvatarBadge = CAvatarBadge;
exports.CAvatarGroup = CAvatarGroup;
exports.CAvatarText = CAvatarText;
exports.avatarGroupProps = avatarGroupProps;
exports.avatarProps = avatarProps;
exports.useAvatarGroup = useAvatarGroup;
