'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var utils = require('@chakra-ui/utils');
var vueComposables = require('@chakra-ui/vue-composables');

var __portal_id__ = 0;
var createPortalTarget = function createPortalTarget(name) {
  if (name === void 0) {
    name = "default";
  }

  var portalId = "chakra__" + name + "__portal__" + __portal_id__;
  var target = document.getElementById(portalId);

  if (!target) {
    target = document.createElement("div");
    target.id = "chakra__" + name + "__portal__" + __portal_id__++;
    /**
     * @todo
     *
     * This may not be the most effective way to hide
     * nodes that are still visible during transitions.
     *
     * So this is a bit of a hack to ensure that teh element
     * doesn't cause the page to jank
     */

    target.style.width = "0";
    target.style.height = "0";
    target.style.overflow = "hidden";
    document.body.appendChild(target);
    return target;
  }

  return target;
};
var ensureTarget = function ensureTarget(selector) {
  if (!utils.isBrowser) {
    console.warn("[chakra-ui:portal]: The CPortal component can only be used in the document");
  }

  if (!document.querySelector(selector)) {
    console.warn("[chakra-ui:portal]: the portal target \"" + selector + "\" cound not be found in the document. Portal children may not be rendered");
  }
};
/** Unmounts portal target when portal is unmounted */

function unmountTarget(targetSelector) {
  var targetNode = document.querySelector(targetSelector);

  try {
    var _targetNode$parentEle;

    targetNode == null ? void 0 : (_targetNode$parentEle = targetNode.parentElement) == null ? void 0 : _targetNode$parentEle.removeChild(targetNode);
  } catch (_unused) {
    utils.warn({
      condition: !targetNode,
      message: "Unable to unmount portal target instance"
    });
  }
}

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !vue.isVNode(s);
}

/**
 * Chakra component to teleport it's children to pre-ordained target.
 *
 * If no target is given to the `CPortal` component via the `to` prop,
 * it will generate a target and append to the document body
 */
var CPortal = vue.defineComponent({
  name: "CPortal",
  props: {
    to: String,
    disabled: Boolean,
    label: String
  },
  setup: function setup(props, _ref) {
    var slots = _ref.slots,
        attrs = _ref.attrs;
    var target = vue.ref(null);
    vue.onBeforeMount(function () {
      if (props.to) {
        ensureTarget(props.to);
        target.value = props.to;
      } else {
        target.value = "#" + createPortalTarget(props.label).id;
      }
    });
    vue.onUnmounted(function () {
      if (!props.to) {
        unmountTarget(target.value);
      }
    });
    vueComposables.useStackProvider();
    return function () {
      return vue.createVNode(vue.Teleport, vue.mergeProps(props, attrs, {
        "to": target.value
      }), _isSlot(slots) ? slots : {
        "default": function _default() {
          return [slots];
        }
      });
    };
  }
});
var CPortal$1 = CPortal;

exports.CPortal = CPortal$1;
