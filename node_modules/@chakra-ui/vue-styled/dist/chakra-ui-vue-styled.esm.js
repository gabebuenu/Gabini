import { mergeProps, createVNode, isVNode, Fragment } from 'vue';
import clsx from 'clsx';
import { serializeStyles } from '@emotion/serialize';
import { createContext, canUseDOM, extractStyleAttrs } from '@chakra-ui/vue-utils';
import { getRegisteredStyles, insertStyles } from '@emotion/utils';
import camelCase from 'lodash.camelcase';
import createCache from '@emotion/cache';
import weakMemoize from '@emotion/weak-memoize';
import memoize from 'lodash.memoize';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _createContext$1 = createContext({
  strict: false,
  name: "EmotionCacheContext"
}),
    EmotionCacheProvider = _createContext$1[0],
    useEmotionCache = _createContext$1[1],
    EmotionCacheInjectionSymbol = _createContext$1[2];

var defaultCache = createCache({
  key: "chakra"
});
var __unusafe_useEmotionCache = useEmotionCache;

var withEmotionCache = function withEmotionCache(fn) {
  return function (p) {
    var cache = useEmotionCache(defaultCache);
    return fn(cache);
  };
};

if (canUseDOM()) {
  withEmotionCache = function withEmotionCache(fn) {
    return function () {
      var cache = useEmotionCache(defaultCache);

      if (!cache) {
        var _cache = createCache({
          key: "chakra"
        });

        EmotionCacheProvider(_cache);
        return fn(_cache);
      } else {
        return fn(cache);
      }
    };
  };
}

var getTheme = function getTheme(outerTheme, theme) {
  if (typeof theme === "function") {
    var mergedTheme = theme(outerTheme);

    if (process.env.NODE_ENV !== "production" && (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme))) {
      throw new Error("[EmotionThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    }

    return mergedTheme;
  }

  if (process.env.NODE_ENV !== "production" && (theme == null || typeof theme !== "object" || Array.isArray(theme))) {
    throw new Error("[EmotionThemeProvider] Please make your theme prop a plain object");
  }

  return _extends({}, outerTheme, theme);
};

var _createContext = createContext({
  strict: false,
  name: "EmotionThemeContext"
}),
    _EmotionThemeProvider = _createContext[0],
    useEmotionTheme = _createContext[1],
    EmotionThemeContextSymbol = _createContext[2];

var createCacheWithTheme = /* #__PURE__ */weakMemoize(function (outerTheme) {
  return weakMemoize(function (theme) {
    return getTheme(outerTheme, theme);
  });
});

function EmotionThemeProvider(theme) {
  var _theme = useEmotionTheme();

  if (theme !== _theme) {
    // @ts-ignore weak map typing not fulfilled properly
    _theme = createCacheWithTheme(_theme)(theme);
  }

  _EmotionThemeProvider(_theme);
}

var _excluded = ["as"];

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !isVNode(s);
}

var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var isBrowser = typeof document !== "undefined";

var Noop = function Noop() {
  return null;
};

var camelCaseCache = {};

var _camelCase = memoize(function (key) {
  return camelCase(key);
}); // @ts-ignore


var createStyled = function createStyled(tag, options) {
  if (process.env.NODE_ENV !== "production") {
    if (tag === undefined) {
      throw new Error("You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.");
    }
  }

  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;

  if (options !== undefined) {
    identifierName = options.__label;
    targetClassName = options.target;
  } // Extract arguments from template literals


  return function () {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];

    if (identifierName !== undefined) {
      styles.push("label:" + identifierName + ";");
    }

    if (args[0] == null || args[0].raw === undefined) {
      styles.push.apply(styles, args);
    } else {
      if (process.env.NODE_ENV !== "production" && args[0][0] === undefined) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }

      styles.push(args[0][0]);
      var len = args.length;
      var i = 1;

      for (; i < len; i++) {
        if (process.env.NODE_ENV !== "production" && args[0][i] === undefined) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
        }

        styles.push(args[i], args[0][i]);
      }
    }

    function StyledComponent(props, _ref) {
      var attrs = _ref.attrs;
          _ref.expose;
          var slots = _ref.slots;

      var cache = __unusafe_useEmotionCache(defaultCache);

      var _ref2 = attrs || {},
          as = _ref2.as,
          restAttrs = _objectWithoutPropertiesLoose(_ref2, _excluded);

      var mergedProps = _extends({}, props, restAttrs);

      var className = options != null && options.__label ? cache.key + "-" + (options != null && options.__label || typeof tag === "string" ? tag : "element") + " " : "";
      var FinalTag = as || baseTag;
      var classInterpolations = [];
      mergedProps = {};

      for (var key in props) {
        if (camelCaseCache[key]) {
          mergedProps[key] = camelCaseCache[key];
        } else {
          var attr = _camelCase(key);

          camelCaseCache[attr] = props[key];
          mergedProps[attr] = props[key];
        }
      }

      if (props.theme == null) {
        mergedProps.theme = useEmotionTheme(undefined);
      }

      mergedProps = mergeProps(_extends({}, attrs, mergedProps));

      if (attrs["class"]) {
        className += getRegisteredStyles(cache.registered, classInterpolations, clsx(attrs["class"]));
      }

      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
      var rules = insertStyles(cache, serialized, typeof FinalTag === "string");
      className += cache.key + "-" + serialized.name;

      if (targetClassName !== undefined) {
        className += " " + targetClassName;
      }

      var _extractStyleAttrs = extractStyleAttrs(mergedProps),
          htmlAttrs = _extractStyleAttrs.attrs;

      var vnodeProps = _extends({}, htmlAttrs, {
        "class": className
      }); // @ts-expect-error


      vnodeProps == null ? true : delete vnodeProps.theme;

      var StyledElement = createVNode(FinalTag, vnodeProps, _isSlot(slots) ? slots : {
        "default": function _default() {
          return [slots];
        }
      });

      var possiblyStyleElement = createVNode(Noop, null, null);

      if (!isBrowser && rules !== undefined) {
        var _ref3;

        var serializedNames = serialized.name;
        var next = serialized.next;

        while (next !== undefined) {
          serializedNames += " " + next.name;
          next = next.next;
        }

        possiblyStyleElement = createVNode("style", (_ref3 = {}, _ref3["data-emotion"] = cache.key + " " + serializedNames, _ref3.nonce = cache.sheet.nonce, _ref3), [rules]);
      }

      return createVNode(Fragment, null, [possiblyStyleElement, StyledElement]);
    }

    StyledComponent._name = identifierName === undefined ? "Styled" + (typeof baseTag === "string" ? baseTag : baseTag.name || "Component") : identifierName;
    StyledComponent.__emotion_real = StyledComponent;
    StyledComponent.__emotion_base = baseTag;
    StyledComponent.__emotion_styles = styles;
    Object.defineProperty(StyledComponent, "toString", {
      value: function value() {
        if (targetClassName === undefined && process.env.NODE_ENV !== "production") {
          return "NO_COMPONENT_SELECTOR";
        }

        return "." + targetClassName;
      }
    });

    StyledComponent.withComponent = function (nextTag, nextOptions) {
      return createStyled(nextTag, nextOptions === undefined ? options : _extends({}, options || {}, nextOptions) // Here we use apply to make TypeScript happy. Otherwise we would use spread operator
      ).apply(null, styles);
    }; // @ts-ignore


    return StyledComponent;
  };
};

var tags = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", // SVG
"circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];

var styled = createStyled.bind();
tags.forEach(function (tagName) {
  // @ts-ignore
  styled[tagName] = styled(tagName);
});

export { EmotionCacheInjectionSymbol, EmotionCacheProvider, EmotionThemeContextSymbol, EmotionThemeProvider, __unusafe_useEmotionCache, createCacheWithTheme as createThemeCache, styled as default, defaultCache, useEmotionTheme, withEmotionCache };
