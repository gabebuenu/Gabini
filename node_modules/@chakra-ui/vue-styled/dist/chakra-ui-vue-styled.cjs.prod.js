'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var clsx = require('clsx');
var serialize = require('@emotion/serialize');
var vueUtils = require('@chakra-ui/vue-utils');
var utils = require('@emotion/utils');
var camelCase = require('lodash.camelcase');
var createCache = require('@emotion/cache');
var weakMemoize = require('@emotion/weak-memoize');
var memoize = require('lodash.memoize');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var clsx__default = /*#__PURE__*/_interopDefault(clsx);
var camelCase__default = /*#__PURE__*/_interopDefault(camelCase);
var createCache__default = /*#__PURE__*/_interopDefault(createCache);
var weakMemoize__default = /*#__PURE__*/_interopDefault(weakMemoize);
var memoize__default = /*#__PURE__*/_interopDefault(memoize);

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _createContext$1 = vueUtils.createContext({
  strict: false,
  name: "EmotionCacheContext"
}),
    EmotionCacheProvider = _createContext$1[0],
    useEmotionCache = _createContext$1[1],
    EmotionCacheInjectionSymbol = _createContext$1[2];

var defaultCache = createCache__default["default"]({
  key: "chakra"
});
var __unusafe_useEmotionCache = useEmotionCache;

exports.withEmotionCache = function withEmotionCache(fn) {
  return function (p) {
    var cache = useEmotionCache(defaultCache);
    return fn(cache);
  };
};

if (vueUtils.canUseDOM()) {
  exports.withEmotionCache = function withEmotionCache(fn) {
    return function () {
      var cache = useEmotionCache(defaultCache);

      if (!cache) {
        var _cache = createCache__default["default"]({
          key: "chakra"
        });

        EmotionCacheProvider(_cache);
        return fn(_cache);
      } else {
        return fn(cache);
      }
    };
  };
}

var getTheme = function getTheme(outerTheme, theme) {
  if (typeof theme === "function") {
    var mergedTheme = theme(outerTheme);

    return mergedTheme;
  }

  return _extends({}, outerTheme, theme);
};

var _createContext = vueUtils.createContext({
  strict: false,
  name: "EmotionThemeContext"
}),
    _EmotionThemeProvider = _createContext[0],
    useEmotionTheme = _createContext[1],
    EmotionThemeContextSymbol = _createContext[2];

var createCacheWithTheme = /* #__PURE__ */weakMemoize__default["default"](function (outerTheme) {
  return weakMemoize__default["default"](function (theme) {
    return getTheme(outerTheme, theme);
  });
});

function EmotionThemeProvider(theme) {
  var _theme = useEmotionTheme();

  if (theme !== _theme) {
    // @ts-ignore weak map typing not fulfilled properly
    _theme = createCacheWithTheme(_theme)(theme);
  }

  _EmotionThemeProvider(_theme);
}

var _excluded = ["as"];

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !vue.isVNode(s);
}
var isBrowser = typeof document !== "undefined";

var Noop = function Noop() {
  return null;
};

var camelCaseCache = {};

var _camelCase = memoize__default["default"](function (key) {
  return camelCase__default["default"](key);
}); // @ts-ignore


var createStyled = function createStyled(tag, options) {

  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;

  if (options !== undefined) {
    identifierName = options.__label;
    targetClassName = options.target;
  } // Extract arguments from template literals


  return function () {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];

    if (identifierName !== undefined) {
      styles.push("label:" + identifierName + ";");
    }

    if (args[0] == null || args[0].raw === undefined) {
      styles.push.apply(styles, args);
    } else {

      styles.push(args[0][0]);
      var len = args.length;
      var i = 1;

      for (; i < len; i++) {

        styles.push(args[i], args[0][i]);
      }
    }

    function StyledComponent(props, _ref) {
      var attrs = _ref.attrs;
          _ref.expose;
          var slots = _ref.slots;

      var cache = __unusafe_useEmotionCache(defaultCache);

      var _ref2 = attrs || {},
          as = _ref2.as,
          restAttrs = _objectWithoutPropertiesLoose(_ref2, _excluded);

      var mergedProps = _extends({}, props, restAttrs);

      var className = options != null && options.__label ? cache.key + "-" + (options != null && options.__label || typeof tag === "string" ? tag : "element") + " " : "";
      var FinalTag = as || baseTag;
      var classInterpolations = [];
      mergedProps = {};

      for (var key in props) {
        if (camelCaseCache[key]) {
          mergedProps[key] = camelCaseCache[key];
        } else {
          var attr = _camelCase(key);

          camelCaseCache[attr] = props[key];
          mergedProps[attr] = props[key];
        }
      }

      if (props.theme == null) {
        mergedProps.theme = useEmotionTheme(undefined);
      }

      mergedProps = vue.mergeProps(_extends({}, attrs, mergedProps));

      if (attrs["class"]) {
        className += utils.getRegisteredStyles(cache.registered, classInterpolations, clsx__default["default"](attrs["class"]));
      }

      var serialized = serialize.serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
      var rules = utils.insertStyles(cache, serialized, typeof FinalTag === "string");
      className += cache.key + "-" + serialized.name;

      if (targetClassName !== undefined) {
        className += " " + targetClassName;
      }

      var _extractStyleAttrs = vueUtils.extractStyleAttrs(mergedProps),
          htmlAttrs = _extractStyleAttrs.attrs;

      var vnodeProps = _extends({}, htmlAttrs, {
        "class": className
      }); // @ts-expect-error


      vnodeProps == null ? true : delete vnodeProps.theme;

      var StyledElement = vue.createVNode(FinalTag, vnodeProps, _isSlot(slots) ? slots : {
        "default": function _default() {
          return [slots];
        }
      });

      var possiblyStyleElement = vue.createVNode(Noop, null, null);

      if (!isBrowser && rules !== undefined) {
        var _ref3;

        var serializedNames = serialized.name;
        var next = serialized.next;

        while (next !== undefined) {
          serializedNames += " " + next.name;
          next = next.next;
        }

        possiblyStyleElement = vue.createVNode("style", (_ref3 = {}, _ref3["data-emotion"] = cache.key + " " + serializedNames, _ref3.nonce = cache.sheet.nonce, _ref3), [rules]);
      }

      return vue.createVNode(vue.Fragment, null, [possiblyStyleElement, StyledElement]);
    }

    StyledComponent._name = identifierName === undefined ? "Styled" + (typeof baseTag === "string" ? baseTag : baseTag.name || "Component") : identifierName;
    StyledComponent.__emotion_real = StyledComponent;
    StyledComponent.__emotion_base = baseTag;
    StyledComponent.__emotion_styles = styles;
    Object.defineProperty(StyledComponent, "toString", {
      value: function value() {
        if (targetClassName === undefined &&         "production" !== "production") {
          return "NO_COMPONENT_SELECTOR";
        }

        return "." + targetClassName;
      }
    });

    StyledComponent.withComponent = function (nextTag, nextOptions) {
      return createStyled(nextTag, nextOptions === undefined ? options : _extends({}, options || {}, nextOptions) // Here we use apply to make TypeScript happy. Otherwise we would use spread operator
      ).apply(null, styles);
    }; // @ts-ignore


    return StyledComponent;
  };
};

var tags = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", // SVG
"circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];

var styled = createStyled.bind();
tags.forEach(function (tagName) {
  // @ts-ignore
  styled[tagName] = styled(tagName);
});

exports.EmotionCacheInjectionSymbol = EmotionCacheInjectionSymbol;
exports.EmotionCacheProvider = EmotionCacheProvider;
exports.EmotionThemeContextSymbol = EmotionThemeContextSymbol;
exports.EmotionThemeProvider = EmotionThemeProvider;
exports.__unusafe_useEmotionCache = __unusafe_useEmotionCache;
exports.createThemeCache = createCacheWithTheme;
exports["default"] = styled;
exports.defaultCache = defaultCache;
exports.useEmotionTheme = useEmotionTheme;
