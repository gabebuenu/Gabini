'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var vueSystem = require('@chakra-ui/vue-system');
var vueUtils = require('@chakra-ui/vue-utils');
var checkbox = require('@zag-js/checkbox');
var vue$1 = require('@zag-js/vue');
var vueComposables = require('@chakra-ui/vue-composables');
var utils = require('@chakra-ui/utils');
var cFormControl = require('@chakra-ui/c-form-control');
var motion = require('@vueuse/motion');
var cMotion = require('@chakra-ui/c-motion');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var checkbox__namespace = /*#__PURE__*/_interopNamespace(checkbox);

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _isSlot$1(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !vue.isVNode(s);
}

var CheckIcon = vue.defineComponent({
  name: "CheckboxCheckIcon",
  setup: function setup(_, _ref) {
    var attrs = _ref.attrs;
        _ref.slots;
    var transitionId = "check-icon-" + vueUtils.genId();
    /** Handles exit transition */

    var leave = function leave(done) {
      var motions = motion.useMotions();
      var instance = motions[transitionId];
      instance == null ? void 0 : instance.leave(function () {
        done();
      });
    };

    vue.onBeforeUnmount(function () {
      leave(function () {
        return null;
      });
    });
    return function () {
      return vue.withDirectives(vue.createVNode(vueSystem.chakra.svg, vue.mergeProps({
        "width": "1.2em",
        "viewBox": "0 0 12 10",
        "style": {
          fill: "none",
          strokeWidth: 2,
          stroke: "currentColor",
          strokeDasharray: 16
        }
      }, attrs), {
        "default": function _default() {
          return vue.createVNode("polyline", {
            "points": "1.5 6 4.5 9 10.5 1"
          }, null);
        }
      }), [[motion.MotionDirective({
        initial: {
          opacity: 0,
          strokeDashoffset: 16,
          transition: cMotion.TransitionDefaults.leave
        },
        enter: {
          opacity: 1,
          strokeDashoffset: 0,
          transition: cMotion.TransitionDefaults.enter
        },
        leave: {
          opacity: 0,
          strokeDashoffset: 16,
          transition: cMotion.TransitionDefaults.leave
        }
      }), transitionId]]);
    };
  }
});
var IndeterminateIcon = vue.defineComponent({
  name: "CheckboxIndeterminateIcon",
  setup: function setup(_, _ref2) {
    var attrs = _ref2.attrs;
        _ref2.slots;
    var transitionId = "indeterminate-icon-" + vueUtils.genId();
    /** Handles exit transition */

    var leave = function leave(done) {
      var motions = motion.useMotions();
      var instance = motions[transitionId];
      instance == null ? void 0 : instance.leave(function () {
        done();
      });
    };

    vue.onBeforeUnmount(function () {
      leave(function () {
        return null;
      });
    });
    return function () {
      return vue.withDirectives(vue.createVNode(vueSystem.chakra.svg, vue.mergeProps({
        "width": "1.2em",
        "viewBox": "0 0 24 24",
        "style": {
          stroke: "currentColor",
          strokeWidth: 4
        }
      }, attrs), {
        "default": function _default() {
          return vue.createVNode("line", {
            "x1": "21",
            "x2": "3",
            "y1": "12",
            "y2": "12"
          }, null);
        }
      }), [[motion.MotionDirective({
        initial: {
          scaleX: 0.65,
          opacity: 0
        },
        enter: {
          scaleX: 1,
          opacity: 1,
          transition: _extends({
            scaleX: {
              duration: 150
            },
            opacity: {
              duration: 150
            }
          }, cMotion.TransitionDefaults.enter)
        },
        leave: {
          scaleX: 0.65,
          opacity: 0,
          transition: cMotion.TransitionDefaults.leave
        }
      }), transitionId]]);
    };
  }
});
var CCheckboxTransition = vue.defineComponent({
  name: "CCheckboxTransition",
  props: {
    open: Boolean
  },
  setup: function setup(props, _ref3) {
    _ref3.attrs;
        var slots = _ref3.slots;
    return function () {
      return vue.createVNode(cMotion.CMotion, {
        "type": "scale",
        "style": {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%"
        }
      }, {
        "default": function _default() {
          return [props.open ? function () {
            return vue.createVNode(vueSystem.chakra.div, null, _isSlot$1(slots) ? slots : {
              "default": function _default() {
                return [slots];
              }
            });
          } : null];
        }
      });
    };
  }
});
var CheckboxIcon = vue.defineComponent(function (props, _ref4) {
  _ref4.slots;
      var attrs = _ref4.attrs;
  var IconEl = vue.computed(function () {
    return props.isIndeterminate ? IndeterminateIcon : CheckIcon;
  });
  return function () {
    return vue.createVNode(CCheckboxTransition, {
      "open": props.isChecked || props.isIndeterminate
    }, {
      "default": function _default() {
        return [vue.createVNode(IconEl.value, attrs, null)];
      }
    });
  };
});
CheckboxIcon.name = "CheckboxIcon";
CheckboxIcon.props = {
  isIndeterminate: Boolean,
  isChecked: Boolean
};

function useCheckboxGroup(props) {
  var modelValue = props.modelValue,
      isDisabled = props.isDisabled;

  function handleChange(value, isChecked) {
    if (!value || !modelValue.value) return;
    modelValue.value = isChecked ? [].concat(new Set([].concat(modelValue.value, [value]))) : modelValue.value.filter(function (v) {
      return String(v) !== String(value);
    });
  }

  return {
    modelValue: modelValue,
    isDisabled: isDisabled,
    handleChange: handleChange
  };
}

var _createContext = vueUtils.createContext({
  strict: false,
  name: "CheckboxGroupContext"
}),
    CheckboxGroupProvider = _createContext[0],
    useCheckboxGroupContext = _createContext[1];

var CCheckboxGroup = vue.defineComponent({
  name: "CCheckboxGroup",
  props: _extends({
    modelValue: {
      type: Object,
      // eslint-disable-next-line vue/require-valid-default-prop
      "default": function _default() {
        return [];
      }
    },
    isDisabled: {
      type: Boolean,
      "default": false
    }
  }, vueUtils.vueThemingProps),
  emits: ["change", "update:modelValue"],
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var checkBoxGroupValue = vue.computed({
      get: function get() {
        return props.modelValue;
      },
      set: function set(value) {
        emit("update:modelValue", value);
      }
    });

    var _useCheckboxGroup = useCheckboxGroup({
      modelValue: checkBoxGroupValue,
      isDisabled: vue.computed(function () {
        return props.isDisabled;
      })
    }),
        modelValue = _useCheckboxGroup.modelValue,
        handleChange = _useCheckboxGroup.handleChange;

    var checkboxGroupContext = vue.computed(function () {
      return {
        size: props.size,
        variant: props.variant,
        isDisabled: props.isDisabled,
        colorScheme: props.colorScheme,
        value: modelValue.value,
        handleChange: handleChange
      };
    });
    CheckboxGroupProvider(checkboxGroupContext);
    return function () {
      return vue.renderSlot(slots, "default");
    };
  }
});

/**
 * - Implement checkbox as state machine.
 * - Implement checkbox as part of group.
 */

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !vue.isVNode(s);
}

var CCheckboxControl = vueSystem.chakra("span", {
  baseStyle: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    verticalAlign: "top",
    userSelect: "none",
    flexShrink: 0
  }
});
var CLabel = vueSystem.chakra("label", {
  baseStyle: {
    cursor: "pointer",
    display: "inline-flex",
    alignItems: "center",
    verticalAlign: "top",
    position: "relative"
  }
});
var CCheckbox = vue.defineComponent({
  name: "CCheckbox",
  props: _extends({
    modelValue: {
      type: Boolean,
      "default": false
    },
    value: [String, Number],
    id: String,
    isIndeterminate: Boolean,
    isFocusable: Boolean,
    isRequired: Boolean,
    isInvalid: Boolean,
    isDisabled: Boolean,
    isReadonly: Boolean,
    defaultChecked: Boolean,
    name: String,
    "aria-label": String,
    "aria-labelledby": String,
    "aria-invalid": Boolean,
    "aria-describedby": String,
    spacing: {
      type: vueUtils.SNAO,
      "default": "0.5rem"
    },
    iconColor: String,
    iconSize: [String, Number],
    icon: Object,
    inputProps: Object
  }, vueUtils.vueThemingProps),
  emits: ["change", "update:modelValue"],
  setup: function setup(props, _ref) {
    var slots = _ref.slots,
        attrs = _ref.attrs,
        emit = _ref.emit;
    var group = useCheckboxGroupContext(vue.computed(function () {
      return {};
    }));
    var ownProps = vue.computed(function () {
      return vueSystem.omitThemingProps(props);
    });
    var mergedProps = vue.computed(function () {
      return utils.mergeWith({}, group.value, props, attrs);
    });
    var styles = vueSystem.useMultiStyleConfig("Checkbox", mergedProps);
    var inheritedFormControlProps = cFormControl.useFormControlContext(mergedProps);
    var id = vueUtils.genId();

    var _useIds = vueComposables.useIds("chakra-checkbox-" + id, "root", "input", "control", "label"),
        rootId = _useIds[0],
        inputId = _useIds[1],
        controlId = _useIds[2],
        labelId = _useIds[3];

    var machineContext = vue.computed(function () {
      var _inheritedFormControl, _inheritedFormControl2, _inheritedFormControl3, _inheritedFormControl4;

      var _inheritedFormControlProps = utils.pick((inheritedFormControlProps == null ? void 0 : inheritedFormControlProps.value) || {}, ["isRequired", "isDisabled", "isInvalid", "isReadOnly"]);

      var cleanedContextProps = utils.filterUndefined({
        readonly: _inheritedFormControlProps == null ? void 0 : (_inheritedFormControl = _inheritedFormControlProps.isReadOnly) == null ? void 0 : _inheritedFormControl.value,
        required: _inheritedFormControlProps == null ? void 0 : (_inheritedFormControl2 = _inheritedFormControlProps.isRequired) == null ? void 0 : _inheritedFormControl2.value,
        disabled: _inheritedFormControlProps == null ? void 0 : (_inheritedFormControl3 = _inheritedFormControlProps.isDisabled) == null ? void 0 : _inheritedFormControl3.value,
        invalid: _inheritedFormControlProps == null ? void 0 : (_inheritedFormControl4 = _inheritedFormControlProps.isInvalid) == null ? void 0 : _inheritedFormControl4.value
      });
      var cleanedOwnProps = utils.filterUndefined({
        required: props.isRequired,
        disabled: props.isDisabled,
        invalid: props.isInvalid,
        readonly: props.isReadonly,
        focusable: props.isFocusable,
        "aria-invalid": props["aria-invalid"],
        "aria-label": props["aria-label"],
        "aria-labelledby": props["aria-labelledby"],
        "aria-describedby": props["aria-describedby"]
      });
      return utils.mergeWith({}, cleanedContextProps, cleanedOwnProps, {
        value: props.value,
        defaultChecked: props.defaultChecked,
        indeterminate: props.isIndeterminate
      });
    });
    var context = vue.computed(function () {
      return _extends({
        id: id,
        ids: {
          root: rootId.value,
          input: inputId.value,
          control: controlId.value,
          labelId: labelId.value
        }
      }, machineContext.value);
    });

    var _useMachine = vue$1.useMachine(checkbox__namespace.machine({
      id: "chakra-ui-checkbox-machine"
    }), {
      context: context
    }),
        state = _useMachine[0],
        send = _useMachine[1];

    var api = vue.computed(function () {
      return checkbox__namespace.connect(state.value, send, vue$1.normalizeProps);
    });
    var iconStyles = vue.computed(function () {
      return _extends({
        opacity: api.value.isChecked || api.value.isIndeterminate ? 1 : 0,
        transform: api.value.isChecked || api.value.isIndeterminate ? "scale(1)" : "scale(0.95)",
        fontSize: props.iconSize,
        color: props.iconColor
      }, styles.value.icon);
    });
    var clonedIcon = vue.computed(function () {
      return vue.cloneVNode(vue.h(CheckboxIcon), {
        __css: iconStyles.value,
        isIndeterminate: api.value.isIndeterminate,
        isChecked: api.value.isChecked
      });
    });
    vue.onMounted(function () {
      if (props.defaultChecked && api.value) {
        api.value.setChecked(true);
      }

      if (api.value) {
        if (group.value.value && ownProps.value.value) {
          var isChecked = group.value.value.includes(ownProps.value.value);
          api.value.setChecked(isChecked);
        }
      }
    });
    vue.watch(function () {
      return api.value.isChecked;
    }, function (value) {
      emit("update:modelValue", value);
      emit("change", value);

      if (group.value.handleChange && ownProps.value.value) {
        group.value.handleChange(ownProps.value.value, value);
      }
    });
    vue.watch(function () {
      return props.modelValue;
    }, function (value) {
      api.value.setChecked(value);
    });
    var inputProps = vue.computed(function () {
      return vue$1.mergeProps(api.value.inputProps, {
        onChange: function onChange() {
          if (api.value.isIndeterminate && !api.value.isReadOnly) {
            api.value.setIndeterminate(false);
            api.value.setChecked(true);
          }
        }
      });
    });
    return function () {
      var children = vueUtils.getValidChildren(slots);
      var hasChildren = children.length > 0;
      console.log("clonedIcon", clonedIcon);
      return vue.createVNode(vueSystem.chakra.div, {
        "sx": {
          "> div": styles.value.container
        }
      }, {
        "default": function _default() {
          return vue.createVNode(CLabel, vue.mergeProps({
            "__label": "checkbox"
          }, api.value.rootProps, {
            "__css": styles.value.container
          }), {
            "default": function _default() {
              return vue.createVNode(vue.Fragment, null, [vue.createVNode("input", vue.mergeProps({
                "class": "chakra-checkbox__input"
              }, inputProps.value), null), vue.createVNode(CCheckboxControl, vue.mergeProps({
                "__label": "checkbox__control",
                "__css": styles.value.control
              }, api.value.controlProps), {
                "default": function _default() {
                  return clonedIcon.value;
                }
              }), hasChildren && vue.createVNode(vueSystem.chakra.span, vue.mergeProps({
                "label": "checkbox__label"
              }, api.value.labelProps, {
                "__css": _extends({
                  marginStart: props.spacing
                }, styles.value.label)
              }), _isSlot(slots) ? slots : {
                "default": function _default() {
                  return [slots];
                }
              })]);
            }
          });
        }
      });
    };
  }
});

exports.CCheckbox = CCheckbox;
exports.CCheckboxGroup = CCheckboxGroup;
exports.useCheckboxGroupContext = useCheckboxGroupContext;
