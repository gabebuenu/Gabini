import { defineComponent, onBeforeUnmount, withDirectives, createVNode, mergeProps, isVNode, computed, renderSlot, cloneVNode, h, onMounted, watch, Fragment } from 'vue';
import { chakra, omitThemingProps, useMultiStyleConfig } from '@chakra-ui/vue-system';
import { genId, createContext, vueThemingProps, SNAO, getValidChildren } from '@chakra-ui/vue-utils';
import * as checkbox from '@zag-js/checkbox';
import { useMachine, normalizeProps, mergeProps as mergeProps$1 } from '@zag-js/vue';
import { useIds } from '@chakra-ui/vue-composables';
import { mergeWith, pick, filterUndefined } from '@chakra-ui/utils';
import { useFormControlContext } from '@chakra-ui/c-form-control';
import { MotionDirective, useMotions } from '@vueuse/motion';
import { TransitionDefaults, CMotion } from '@chakra-ui/c-motion';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _isSlot$1(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !isVNode(s);
}

var CheckIcon = defineComponent({
  name: "CheckboxCheckIcon",
  setup: function setup(_, _ref) {
    var attrs = _ref.attrs;
        _ref.slots;
    var transitionId = "check-icon-" + genId();
    /** Handles exit transition */

    var leave = function leave(done) {
      var motions = useMotions();
      var instance = motions[transitionId];
      instance == null ? void 0 : instance.leave(function () {
        done();
      });
    };

    onBeforeUnmount(function () {
      leave(function () {
        return null;
      });
    });
    return function () {
      return withDirectives(createVNode(chakra.svg, mergeProps({
        "width": "1.2em",
        "viewBox": "0 0 12 10",
        "style": {
          fill: "none",
          strokeWidth: 2,
          stroke: "currentColor",
          strokeDasharray: 16
        }
      }, attrs), {
        "default": function _default() {
          return createVNode("polyline", {
            "points": "1.5 6 4.5 9 10.5 1"
          }, null);
        }
      }), [[MotionDirective({
        initial: {
          opacity: 0,
          strokeDashoffset: 16,
          transition: TransitionDefaults.leave
        },
        enter: {
          opacity: 1,
          strokeDashoffset: 0,
          transition: TransitionDefaults.enter
        },
        leave: {
          opacity: 0,
          strokeDashoffset: 16,
          transition: TransitionDefaults.leave
        }
      }), transitionId]]);
    };
  }
});
var IndeterminateIcon = defineComponent({
  name: "CheckboxIndeterminateIcon",
  setup: function setup(_, _ref2) {
    var attrs = _ref2.attrs;
        _ref2.slots;
    var transitionId = "indeterminate-icon-" + genId();
    /** Handles exit transition */

    var leave = function leave(done) {
      var motions = useMotions();
      var instance = motions[transitionId];
      instance == null ? void 0 : instance.leave(function () {
        done();
      });
    };

    onBeforeUnmount(function () {
      leave(function () {
        return null;
      });
    });
    return function () {
      return withDirectives(createVNode(chakra.svg, mergeProps({
        "width": "1.2em",
        "viewBox": "0 0 24 24",
        "style": {
          stroke: "currentColor",
          strokeWidth: 4
        }
      }, attrs), {
        "default": function _default() {
          return createVNode("line", {
            "x1": "21",
            "x2": "3",
            "y1": "12",
            "y2": "12"
          }, null);
        }
      }), [[MotionDirective({
        initial: {
          scaleX: 0.65,
          opacity: 0
        },
        enter: {
          scaleX: 1,
          opacity: 1,
          transition: _extends({
            scaleX: {
              duration: 150
            },
            opacity: {
              duration: 150
            }
          }, TransitionDefaults.enter)
        },
        leave: {
          scaleX: 0.65,
          opacity: 0,
          transition: TransitionDefaults.leave
        }
      }), transitionId]]);
    };
  }
});
var CCheckboxTransition = defineComponent({
  name: "CCheckboxTransition",
  props: {
    open: Boolean
  },
  setup: function setup(props, _ref3) {
    _ref3.attrs;
        var slots = _ref3.slots;
    return function () {
      return createVNode(CMotion, {
        "type": "scale",
        "style": {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%"
        }
      }, {
        "default": function _default() {
          return [props.open ? function () {
            return createVNode(chakra.div, null, _isSlot$1(slots) ? slots : {
              "default": function _default() {
                return [slots];
              }
            });
          } : null];
        }
      });
    };
  }
});
var CheckboxIcon = defineComponent(function (props, _ref4) {
  _ref4.slots;
      var attrs = _ref4.attrs;
  var IconEl = computed(function () {
    return props.isIndeterminate ? IndeterminateIcon : CheckIcon;
  });
  return function () {
    return createVNode(CCheckboxTransition, {
      "open": props.isChecked || props.isIndeterminate
    }, {
      "default": function _default() {
        return [createVNode(IconEl.value, attrs, null)];
      }
    });
  };
});
CheckboxIcon.name = "CheckboxIcon";
CheckboxIcon.props = {
  isIndeterminate: Boolean,
  isChecked: Boolean
};

function useCheckboxGroup(props) {
  var modelValue = props.modelValue,
      isDisabled = props.isDisabled;

  function handleChange(value, isChecked) {
    if (!value || !modelValue.value) return;
    modelValue.value = isChecked ? [].concat(new Set([].concat(modelValue.value, [value]))) : modelValue.value.filter(function (v) {
      return String(v) !== String(value);
    });
  }

  return {
    modelValue: modelValue,
    isDisabled: isDisabled,
    handleChange: handleChange
  };
}

var _createContext = createContext({
  strict: false,
  name: "CheckboxGroupContext"
}),
    CheckboxGroupProvider = _createContext[0],
    useCheckboxGroupContext = _createContext[1];

var CCheckboxGroup = defineComponent({
  name: "CCheckboxGroup",
  props: _extends({
    modelValue: {
      type: Object,
      // eslint-disable-next-line vue/require-valid-default-prop
      "default": function _default() {
        return [];
      }
    },
    isDisabled: {
      type: Boolean,
      "default": false
    }
  }, vueThemingProps),
  emits: ["change", "update:modelValue"],
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var checkBoxGroupValue = computed({
      get: function get() {
        return props.modelValue;
      },
      set: function set(value) {
        emit("update:modelValue", value);
      }
    });

    var _useCheckboxGroup = useCheckboxGroup({
      modelValue: checkBoxGroupValue,
      isDisabled: computed(function () {
        return props.isDisabled;
      })
    }),
        modelValue = _useCheckboxGroup.modelValue,
        handleChange = _useCheckboxGroup.handleChange;

    var checkboxGroupContext = computed(function () {
      return {
        size: props.size,
        variant: props.variant,
        isDisabled: props.isDisabled,
        colorScheme: props.colorScheme,
        value: modelValue.value,
        handleChange: handleChange
      };
    });
    CheckboxGroupProvider(checkboxGroupContext);
    return function () {
      return renderSlot(slots, "default");
    };
  }
});

/**
 * - Implement checkbox as state machine.
 * - Implement checkbox as part of group.
 */

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !isVNode(s);
}

var CCheckboxControl = chakra("span", {
  baseStyle: {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    verticalAlign: "top",
    userSelect: "none",
    flexShrink: 0
  }
});
var CLabel = chakra("label", {
  baseStyle: {
    cursor: "pointer",
    display: "inline-flex",
    alignItems: "center",
    verticalAlign: "top",
    position: "relative"
  }
});
var CCheckbox = defineComponent({
  name: "CCheckbox",
  props: _extends({
    modelValue: {
      type: Boolean,
      "default": false
    },
    value: [String, Number],
    id: String,
    isIndeterminate: Boolean,
    isFocusable: Boolean,
    isRequired: Boolean,
    isInvalid: Boolean,
    isDisabled: Boolean,
    isReadonly: Boolean,
    defaultChecked: Boolean,
    name: String,
    "aria-label": String,
    "aria-labelledby": String,
    "aria-invalid": Boolean,
    "aria-describedby": String,
    spacing: {
      type: SNAO,
      "default": "0.5rem"
    },
    iconColor: String,
    iconSize: [String, Number],
    icon: Object,
    inputProps: Object
  }, vueThemingProps),
  emits: ["change", "update:modelValue"],
  setup: function setup(props, _ref) {
    var slots = _ref.slots,
        attrs = _ref.attrs,
        emit = _ref.emit;
    var group = useCheckboxGroupContext(computed(function () {
      return {};
    }));
    var ownProps = computed(function () {
      return omitThemingProps(props);
    });
    var mergedProps = computed(function () {
      return mergeWith({}, group.value, props, attrs);
    });
    var styles = useMultiStyleConfig("Checkbox", mergedProps);
    var inheritedFormControlProps = useFormControlContext(mergedProps);
    var id = genId();

    var _useIds = useIds("chakra-checkbox-" + id, "root", "input", "control", "label"),
        rootId = _useIds[0],
        inputId = _useIds[1],
        controlId = _useIds[2],
        labelId = _useIds[3];

    var machineContext = computed(function () {
      var _inheritedFormControl, _inheritedFormControl2, _inheritedFormControl3, _inheritedFormControl4;

      var _inheritedFormControlProps = pick((inheritedFormControlProps == null ? void 0 : inheritedFormControlProps.value) || {}, ["isRequired", "isDisabled", "isInvalid", "isReadOnly"]);

      var cleanedContextProps = filterUndefined({
        readonly: _inheritedFormControlProps == null ? void 0 : (_inheritedFormControl = _inheritedFormControlProps.isReadOnly) == null ? void 0 : _inheritedFormControl.value,
        required: _inheritedFormControlProps == null ? void 0 : (_inheritedFormControl2 = _inheritedFormControlProps.isRequired) == null ? void 0 : _inheritedFormControl2.value,
        disabled: _inheritedFormControlProps == null ? void 0 : (_inheritedFormControl3 = _inheritedFormControlProps.isDisabled) == null ? void 0 : _inheritedFormControl3.value,
        invalid: _inheritedFormControlProps == null ? void 0 : (_inheritedFormControl4 = _inheritedFormControlProps.isInvalid) == null ? void 0 : _inheritedFormControl4.value
      });
      var cleanedOwnProps = filterUndefined({
        required: props.isRequired,
        disabled: props.isDisabled,
        invalid: props.isInvalid,
        readonly: props.isReadonly,
        focusable: props.isFocusable,
        "aria-invalid": props["aria-invalid"],
        "aria-label": props["aria-label"],
        "aria-labelledby": props["aria-labelledby"],
        "aria-describedby": props["aria-describedby"]
      });
      return mergeWith({}, cleanedContextProps, cleanedOwnProps, {
        value: props.value,
        defaultChecked: props.defaultChecked,
        indeterminate: props.isIndeterminate
      });
    });
    var context = computed(function () {
      return _extends({
        id: id,
        ids: {
          root: rootId.value,
          input: inputId.value,
          control: controlId.value,
          labelId: labelId.value
        }
      }, machineContext.value);
    });

    var _useMachine = useMachine(checkbox.machine({
      id: "chakra-ui-checkbox-machine"
    }), {
      context: context
    }),
        state = _useMachine[0],
        send = _useMachine[1];

    var api = computed(function () {
      return checkbox.connect(state.value, send, normalizeProps);
    });
    var iconStyles = computed(function () {
      return _extends({
        opacity: api.value.isChecked || api.value.isIndeterminate ? 1 : 0,
        transform: api.value.isChecked || api.value.isIndeterminate ? "scale(1)" : "scale(0.95)",
        fontSize: props.iconSize,
        color: props.iconColor
      }, styles.value.icon);
    });
    var clonedIcon = computed(function () {
      return cloneVNode(h(CheckboxIcon), {
        __css: iconStyles.value,
        isIndeterminate: api.value.isIndeterminate,
        isChecked: api.value.isChecked
      });
    });
    onMounted(function () {
      if (props.defaultChecked && api.value) {
        api.value.setChecked(true);
      }

      if (api.value) {
        if (group.value.value && ownProps.value.value) {
          var isChecked = group.value.value.includes(ownProps.value.value);
          api.value.setChecked(isChecked);
        }
      }
    });
    watch(function () {
      return api.value.isChecked;
    }, function (value) {
      emit("update:modelValue", value);
      emit("change", value);

      if (group.value.handleChange && ownProps.value.value) {
        group.value.handleChange(ownProps.value.value, value);
      }
    });
    watch(function () {
      return props.modelValue;
    }, function (value) {
      api.value.setChecked(value);
    });
    var inputProps = computed(function () {
      return mergeProps$1(api.value.inputProps, {
        onChange: function onChange() {
          if (api.value.isIndeterminate && !api.value.isReadOnly) {
            api.value.setIndeterminate(false);
            api.value.setChecked(true);
          }
        }
      });
    });
    return function () {
      var children = getValidChildren(slots);
      var hasChildren = children.length > 0;
      console.log("clonedIcon", clonedIcon);
      return createVNode(chakra.div, {
        "sx": {
          "> div": styles.value.container
        }
      }, {
        "default": function _default() {
          return createVNode(CLabel, mergeProps({
            "__label": "checkbox"
          }, api.value.rootProps, {
            "__css": styles.value.container
          }), {
            "default": function _default() {
              return createVNode(Fragment, null, [createVNode("input", mergeProps({
                "class": "chakra-checkbox__input"
              }, inputProps.value), null), createVNode(CCheckboxControl, mergeProps({
                "__label": "checkbox__control",
                "__css": styles.value.control
              }, api.value.controlProps), {
                "default": function _default() {
                  return clonedIcon.value;
                }
              }), hasChildren && createVNode(chakra.span, mergeProps({
                "label": "checkbox__label"
              }, api.value.labelProps, {
                "__css": _extends({
                  marginStart: props.spacing
                }, styles.value.label)
              }), _isSlot(slots) ? slots : {
                "default": function _default() {
                  return [slots];
                }
              })]);
            }
          });
        }
      });
    };
  }
});

export { CCheckbox, CCheckboxGroup, useCheckboxGroupContext };
