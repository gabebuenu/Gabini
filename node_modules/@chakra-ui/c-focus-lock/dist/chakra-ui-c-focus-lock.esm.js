import { ref, watchEffect, onUpdated, onUnmounted, onBeforeMount, onBeforeUnmount, defineComponent, computed, unref, cloneVNode, createVNode, mergeProps } from 'vue';
import { warn, __DEV__ } from '@chakra-ui/utils';
import { Keys, focusIn, Focus, FocusResult, contains, focusElement, getSelector, unrefElement } from '@chakra-ui/vue-utils';
import { useWindowEvent } from '@chakra-ui/vue-composables';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function useFocusTrap(containers, enabled, options) {
  if (enabled === void 0) {
    enabled = ref(true);
  }

  if (options === void 0) {
    options = ref({});
  }

  var restoreElement = ref(typeof window !== "undefined" ? document.activeElement : null);
  var previousActiveElement = ref(null);

  function handleFocus() {
    if (!enabled.value) return;
    if (containers.value.size !== 1) return;
    var initialFocus = options.value.initialFocus;
    var activeElement = document.activeElement;

    if (initialFocus) {
      if (initialFocus === activeElement) {
        return; // Initial focus ref is already the active element
      }
    } else if (contains(containers.value, activeElement)) {
      return; // Already focused within Dialog
    }

    restoreElement.value = activeElement; // Try to focus the initialFocus ref

    if (initialFocus) {
      focusElement(initialFocus);
    } else {
      var couldFocus = false;

      for (var _iterator = _createForOfIteratorHelperLoose(containers.value), _step; !(_step = _iterator()).done;) {
        var container = _step.value;
        var result = focusIn(container, Focus.First);

        if (result === FocusResult.Success) {
          couldFocus = true;
          break;
        }
      }

      if (!couldFocus) console.warn("There are no focusable elements inside the <FocusTrap />");
    }

    previousActiveElement.value = document.activeElement;
  } // Restore when `enabled` becomes false


  function restore() {
    focusElement(restoreElement.value);
    restoreElement.value = null;
    previousActiveElement.value = null;
  } // Handle initial focus


  watchEffect(handleFocus);
  onUpdated(function () {
    enabled.value ? handleFocus() : restore();
  });
  onUnmounted(restore); // Handle Tab & Shift+Tab keyboard events

  useWindowEvent("keydown", function (event) {
    if (!enabled.value) return;
    if (event.key !== Keys.Tab) return;
    if (!document.activeElement) return;
    if (containers.value.size !== 1) return;
    event.preventDefault();

    for (var _iterator2 = _createForOfIteratorHelperLoose(containers.value), _step2; !(_step2 = _iterator2()).done;) {
      var element = _step2.value;
      var result = focusIn(element, (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround);

      if (result === FocusResult.Success) {
        previousActiveElement.value = document.activeElement;
        break;
      }
    }
  }); // Prevent programmatically escaping

  useWindowEvent("focus", function (event) {
    if (!enabled.value) return;
    if (containers.value.size !== 1) return;
    var previous = previousActiveElement.value;
    if (!previous) return;
    var toElement = event.target;

    if (toElement && toElement instanceof HTMLElement) {
      if (!contains(containers.value, toElement)) {
        event.preventDefault();
        event.stopPropagation();
        focusElement(previous);
      } else {
        previousActiveElement.value = toElement;
        focusElement(toElement);
      }
    } else {
      focusElement(previousActiveElement.value);
    }
  }, true);
}
function useReturnFocusSelector(shouldTrack) {
  var lastFocused = ref(null);
  var lastFocusedSelector = ref();

  var trackFocus = function trackFocus(event) {
    if (!shouldTrack.value) {
      lastFocusedSelector.value = getSelector(event.target);
    }
  };

  onBeforeMount(function () {
    document.addEventListener("focusin", trackFocus);
  });
  onBeforeUnmount(function () {
    document.removeEventListener("focusin", trackFocus);
    lastFocused.value = null;
    lastFocusedSelector.value = undefined;
  });
  return {
    lastFocused: lastFocused,
    lastFocusedSelector: lastFocusedSelector
  };
}

var CFocusLock = defineComponent({
  name: "CFocusLock",
  emits: ["activate", "deactivate"],
  props: {
    finalFocusRef: [String, Object, Function],
    initialFocusRef: [String, Object, Function],
    autoFocus: {
      type: Boolean,
      "default": true
    },
    escapeDeactivates: {
      type: Boolean,
      "default": false
    },
    clickOutsideDeactivates: {
      type: Boolean,
      "default": false
    },
    allowOutsideClick: {
      type: Boolean,
      "default": false
    },
    restoreFocus: {
      type: Boolean,
      "default": true
    }
  },
  setup: function setup(props, _ref) {
    var attrs = _ref.attrs,
        slots = _ref.slots;
        _ref.emit;
    var target = ref();
    var initialFocusElement = computed(function () {
      var initialFocus;

      if (props.initialFocusRef) {
        var resolvedInitialFocusRef = typeof props.initialFocusRef === "function" ? props.initialFocusRef() : props.initialFocusRef;
        resolvedInitialFocusRef = unref(resolvedInitialFocusRef);

        if (typeof resolvedInitialFocusRef === "string") {
          initialFocus = document.querySelector(resolvedInitialFocusRef);
        } else {
          var _resolvedInitialFocus;

          initialFocus = ((_resolvedInitialFocus = resolvedInitialFocusRef) == null ? void 0 : _resolvedInitialFocus.$el) || resolvedInitialFocusRef;
        }
      }

      return initialFocus;
    });
    var enabled = ref(true);

    function activate() {
      enabled.value = true;
    }

    function deactivate() {
      enabled.value = false;
    }

    var hasFocus = computed(function () {
      return enabled.value === true;
    });
    var containers = ref(new Set());
    watchEffect(function (onInvalidate) {
      var el;

      if (target.value) {
        el = unrefElement(target);
        containers.value.add(el);
      }

      onInvalidate(function () {
        containers.value["delete"](el);
      });
    }, {
      flush: "post"
    });
    useReturnFocusSelector(enabled);
    useFocusTrap(containers, enabled, computed(function () {
      return {
        initialFocus: initialFocusElement.value
      };
    }));
    return function () {
      var _ref2 = slots["default"] == null ? void 0 : slots["default"]({}),
          firstChild = _ref2[0];

      if (!firstChild) {
        warn({
          condition: __DEV__,
          message: "[chakra-ui:focus-lock]: Focus lock component expects at least and only one child element."
        });
        return;
      }

      var clone = cloneVNode(firstChild, _extends({
        ref: target
      }, attrs, {
        "data-chakra-focus-lock": ""
      }));
      return createVNode(clone, mergeProps({
        "ref": target,
        "data-chakra-focus-lock": ""
      }, attrs), {
        "default": function _default() {
          return [slots == null ? void 0 : slots["default"] == null ? void 0 : slots["default"]({
            enabled: enabled,
            hasFocus: hasFocus,
            activate: activate,
            deactivate: deactivate
          })];
        }
      });
    };
  }
});

export { CFocusLock, useFocusTrap, useReturnFocusSelector };
