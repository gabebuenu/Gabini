import { computed, unref, ref, watchSyncEffect, defineComponent, createVNode, mergeProps, reactive, watchEffect } from 'vue';
import { chakra } from '@chakra-ui/vue-system';
import { omit } from '@chakra-ui/utils';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function useImage(props) {
  var loading = props.loading,
      src = props.src,
      srcSet = props.srcSet,
      onLoad = props.onLoad,
      onError = props.onError,
      crossOrigin = props.crossOrigin,
      sizes = props.sizes,
      ignoreFallback = props.ignoreFallback;
  var status = ref("pending");
  var imageRef;

  var flush = function flush() {
    if (imageRef) {
      imageRef.onload = null;
      imageRef.onerror = null;
      imageRef = null;
    }
  };

  var load = function load() {
    if (!src) return;
    flush(); // Create instance to check content for status

    var img = new Image();
    img.src = src;
    if (crossOrigin) img.crossOrigin = crossOrigin;
    if (srcSet) img.srcset = srcSet;
    if (sizes) img.sizes = sizes;
    if (loading) img.loading = loading;

    img.onload = function (event) {
      flush();
      status.value = "loaded";
      onLoad == null ? void 0 : onLoad(event);
    };

    img.onerror = function (error) {
      flush();
      status.value = "failed";
      onError == null ? void 0 : onError(error);
    };

    imageRef = img;
  };

  watchSyncEffect(function () {
    /**
     * If user opts out of the fallback/placeholder
     * logic, let's bail out.
     */
    if (unref(ignoreFallback)) return undefined;

    if (src) {
      // Loading...
      load();
    }
  });
  /**
   * If user opts out of the fallback/placeholder
   * logic, let's just return 'loaded'
   */

  return computed(function () {
    return unref(ignoreFallback) ? "loaded" : status.value;
  });
}
var shouldShowFallbackImage = function shouldShowFallbackImage(status, fallbackStrategy) {
  return status !== "loaded" && fallbackStrategy === "beforeLoadOrError" || status === "failed" && fallbackStrategy === "onError";
};

var CNativeImage = defineComponent({
  name: "CNativeImage",
  props: {
    htmlWidth: [String, Number],
    htmlHeight: [String, Number],
    alt: String
  },
  setup: function setup(props, _ref) {
    var attrs = _ref.attrs;
    return function () {
      return createVNode("img", mergeProps({
        "width": props.htmlWidth,
        "height": props.htmlHeight,
        "alt": props.alt
      }, attrs), null);
    };
  }
});

// @ts-ignore
var CImage = defineComponent({
  name: "CImage",
  props: {
    as: {
      type: [Object, String],
      "default": "img"
    },
    fallbackSrc: String,
    loading: String,
    fit: String,
    align: String,
    ignoreFallback: Boolean,
    fallbackStrategy: {
      type: String,
      "default": "beforeLoadOrError"
    },
    referrerPolicy: String,
    htmlWidth: [String, Number],
    htmlHeight: [String, Number],
    src: String,
    srcSet: String,
    sizes: String,
    onLoad: Function,
    onError: Function,
    crossOrigin: String
  },
  setup: function setup(props, _ref) {
    var slots = _ref.slots,
        attrs = _ref.attrs;
    var rest = reactive({
      width: props.htmlWidth,
      height: props.htmlHeight,
      onLoad: props.onLoad,
      onError: props.onError
    });
    var providedFallback = computed(function () {
      return props.fallbackSrc !== undefined || !!(slots != null && slots["default"] != null && slots["default"]());
    });
    var shouldIgnoreFallbackImage = ref();
    var showFallbackImage = ref(false);
    var status = useImage(_extends({}, props, {
      ignoreFallback: computed(function () {
        return shouldIgnoreFallbackImage.value;
      })
    }));
    watchEffect(function () {
      shouldIgnoreFallbackImage.value = props.loading != null || unref(props.ignoreFallback) || !providedFallback.value;
      showFallbackImage.value = shouldShowFallbackImage(status.value, props.fallbackStrategy);
    });
    var shared = computed(function () {
      return _extends({
        objectFit: props.fit,
        objectPosition: props.align
      }, attrs, shouldIgnoreFallbackImage.value ? rest : omit(rest, ["onError", "onLoad"]));
    });
    return function () {
      if (showFallbackImage.value) {
        if (slots["default"]) return slots["default"]();
        return createVNode(chakra.img, mergeProps({
          "as": CNativeImage,
          "class": "chakra-image__placeholder",
          "src": props.fallbackSrc
        }, shared.value), null);
      }

      return createVNode(chakra.img, mergeProps({
        "as": CNativeImage,
        "src": props.src,
        "srcset": props.srcSet,
        "crossOrigin": props.crossOrigin,
        "loading": props.loading,
        "referrerPolicy": props.referrerPolicy,
        "class": "chakra-image"
      }, shared.value), null);
    };
  }
});

/**
 * Fallback component for SSR users who want to use the native `img` with
 * support for chakra props
 */
var CImg = defineComponent({
  name: "CImg",
  setup: function setup(_, _ref) {
    var attrs = _ref.attrs;
    return function () {
      return createVNode(chakra.img, mergeProps({
        "as": CNativeImage,
        "class": "chakra-image"
      }, attrs), null);
    };
  }
});

export { CImage, CImg };
